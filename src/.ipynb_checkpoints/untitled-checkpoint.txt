
我希望使用julia编写一个TOV模拟软件，最终达到类似Einstein toolkit的效果，我是在使用julia编写代码，请输出符合语法和格式要求的代码，我希望每个jl模块文件前有一个简短的说明包括文件名，实现的功能，依赖等，同时使用中文对代码进行注释，不要用php或R等。我现在已经初步完成如下，由于字数太多我会分成两部分发送，请在收到完整的两部分之后分析全部代码，结合我的任务提出扩展或改进意见，下面是第一部分：
module AdvancedParallel

using Distributed
using LinearAlgebra
using CUDA
using Dates
using Base.Threads: Atomic, atomic_add!
using Random

export async_gpu_exchange, async_mixed_communication, create_sync_channel,
       async_workflow_with_sync, parallel_workflow_with_tuning, get_parallel_performance_report,
       advanced_async_communication, optimized_communication, recover_communication_with_redundancy

# ------------------------------
# 性能调优接口
# ------------------------------
const parallel_params = Dict{Symbol,Any}(
    :comm_buffer_size => 1024,   # 通信缓冲区大小（字节数）
    :comm_interval => 0.1,       # 通信间隔（秒）
    :async_task_count => 4,      # 异步任务数
)

function set_parallel_params(params::Dict{Symbol,Any})
    for (k,v) in params
        parallel_params[k] = v
    end
end

function get_parallel_params()
    return deepcopy(parallel_params)
end

# ------------------------------
# GPU 加速与混合并行接口
# ------------------------------
function async_gpu_exchange(data::Array{Float64}, device_id::Int)
    if !CUDA.has_cuda()
        @warn "GPU 不可用！"
        return nothing
    end
    fut = @async begin
        try
            CUDA.device!(device_id)
            d_data = CuArray(data)
            d_result = d_data .^ 2  # 示例计算
            result = Array(d_result)
            return result
        catch e
            @warn "GPU 任务错误: $e"
            return nothing
        end
    end
    return fut
end

function async_mixed_communication(data::Array{Float64}, device_id::Int)
    gpu_future = async_gpu_exchange(data, device_id)
    cpu_future = @async sum(data)
    return @async begin
        gpu_result = fetch(gpu_future)
        cpu_result = fetch(cpu_future)
        return (gpu_result, cpu_result)
    end
end

# ------------------------------
# 优化通信：独立通信优化、异步通信
# ------------------------------

"""
    optimized_communication(field_data::Dict{Symbol, Array{Float64, 1}}, comm_buffer_size::Int=1024) -> RemoteChannel

优化后的通信方法，针对不同物理场（如温度、压力、密度等）分别进行独立的通信优化。
"""
function optimized_communication(field_data::Dict{Symbol, Array{Float64, 1}}, comm_buffer_size::Int=1024)
    # 创建异步通信通道
    comm_channel = RemoteChannel(() -> Channel{Any}(comm_buffer_size))
    
    @async begin
        for (key, data) in field_data
            # 根据物理场数据的大小决定是否分批传输
            chunk_size = min(comm_buffer_size, length(data))
            for i in 1:chunk_size:length(data)
                # 分批传输数据，减少冗余数据传输
                chunk = data[i:min(i+chunk_size-1, length(data))]
                put!(comm_channel, (key, chunk))
            end
        end
    end
    return comm_channel
end

# ------------------------------
# 容错机制扩展：检查点与冗余恢复
# ------------------------------

const checkpoint_storage = Dict{Int, Any}()
const redundancy_storage = Dict{Int, Any}()

"""
    save_checkpoint_with_redundancy(proc_id::Int, data, redundancy_factor::Int=2)

保存当前进程的数据检查点，并生成冗余数据进行灾难恢复。
"""
function save_checkpoint_with_redundancy(proc_id::Int, data, redundancy_factor::Int=2)
    checkpoint_storage[proc_id] = data
    # 创建冗余数据
    redundant_data = repeat([data], redundancy_factor)
    redundancy_storage[proc_id] = redundant_data
end

"""
    load_checkpoint_with_redundancy(proc_id::Int) -> Any

尝试加载检查点数据，如果无法加载，尝试使用冗余数据进行恢复。
"""
function load_checkpoint_with_redundancy(proc_id::Int)
    cp = get(checkpoint_storage, proc_id, nothing)
    if cp !== nothing
        @info "从检查点恢复 proc_id=$proc_id 的数据"
        return cp
    else
        # 尝试使用冗余数据进行恢复
        redundant_data = get(redundancy_storage, proc_id, nothing)
        if redundant_data !== nothing
            @info "使用冗余数据恢复 proc_id=$proc_id"
            return redundant_data[1]  # 返回冗余数据的第一份
        else
            @warn "检查点和冗余数据均不可用，任务失败"
            return nothing
        end
    end
end

"""
    recover_communication_with_redundancy(proc_id::Int, f::Function) -> Any

尝试恢复通信，首先尝试加载检查点数据，如果不存在则加载冗余数据，否则重新执行函数f。
"""
function recover_communication_with_redundancy(proc_id::Int, f::Function)
    cp = load_checkpoint_with_redundancy(proc_id)
    if cp !== nothing
        return cp
    else
        @warn "检查点和冗余数据丢失，重新执行任务"
        result = f()
        save_checkpoint_with_redundancy(proc_id, result)
        return result
    end
end

# ------------------------------
# 性能调优与调试接口
# ------------------------------

"""
    get_parallel_performance_report() -> Dict{Symbol,Any}

返回当前并行通信统计信息，包括总通信时间、传输字节、调用次数、错误次数等。
"""
function get_parallel_performance_report()
    return Dict(
       :total_time  => parallel_params[:total_time].value,
       :total_bytes => parallel_params[:total_bytes].value,
       :calls       => parallel_params[:calls].value,
       :errors      => parallel_params[:errors].value,
    )
end

end  # module AdvancedParallel


module AMRModule

using LinearAlgebra
using CUDA

export AdaptiveMeshRefinement, refine_grid, compute_gradient, adaptive_timestep,
       refine_grid_gpu!, compute_gradient_gpu, compute_gradient_kernel

# --------------------------
# 自适应网格细化 (AMR)
# --------------------------

"""
    AdaptiveMeshRefinement

自适应网格细化类，根据物理量的梯度自动调整网格分辨率。
"""
mutable struct AdaptiveMeshRefinement
    grid_size::Int
    max_refinement_level::Int
    min_refinement_level::Int
    refinement_threshold::Float64
    spacing::Float64
    coordinates::Dict{Symbol, Array{Float64, 1}}   # 用于存储不同维度的网格坐标
    physical_fields::Dict{Symbol, Array{Float64, 1}} # 存储物理场，如密度、温度、压力等
    current_refinement_level::Int  # 当前网格细化级别
end

# --------------------------
# 网格细化函数
# --------------------------

"""
    refine_grid!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)

根据物理场的梯度自动细化网格，并根据网格细化级别动态调整EOS。
"""
function refine_grid!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient(amr, field)

    # 根据梯度细化网格
    for i in 1:length(gradient)
        if gradient[i] > amr.refinement_threshold
            # 对需要细化的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格")
        elseif gradient[i] < amr.refinement_threshold / 2
            # 对变化较小的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

# --------------------------
# 计算梯度
# --------------------------

"""
    compute_gradient(amr::AdaptiveMeshRefinement, field::Symbol)

计算物理场（如温度、密度、压力等）的梯度，帮助判断在哪些区域需要进行网格细化。
"""
function compute_gradient(amr::AdaptiveMeshRefinement, field::Symbol)
    field_data = amr.physical_fields[field]
    gradient = zeros(Float64, length(field_data))

    # 简化的梯度计算方法（可以使用更复杂的离散化方法）
    for i in 2:length(field_data)-1
        gradient[i] = (field_data[i+1] - field_data[i-1]) / (amr.spacing)
    end

    return gradient
end

# --------------------------
# 自适应时间步长选择
# --------------------------

"""
    adaptive_timestep!(amr::AdaptiveMeshRefinement, dt::Float64, eos::FiniteTempEOS)

根据物理场的梯度和网格大小自动调整时间步长。
"""
function adaptive_timestep!(amr::AdaptiveMeshRefinement, dt::Float64, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient(amr, :temperature)

    # 自动调整时间步长（例如在高梯度区域使用更小的时间步长）
    max_gradient = maximum(abs.(gradient))
    dt_adjustment_factor = 1.0 / (1.0 + max_gradient)  # 较大梯度区域，时间步长较小
    new_dt = dt * dt_adjustment_factor

    # 根据当前网格细化级别调整时间步长
    new_dt *= 2.0^(amr.current_refinement_level - 1)

    return new_dt
end

# --------------------------
# GPU加速相关功能
# --------------------------

"""
    refine_grid_gpu!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)

GPU加速版本的网格细化函数，利用CUDA加速梯度计算和网格细化过程，并根据细化级别调整EOS。
"""
function refine_grid_gpu!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient_gpu(amr, field)

    # 根据梯度细化网格
    for i in 1:length(gradient)
        if gradient[i] > amr.refinement_threshold
            # 对需要细化的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格 (GPU加速)")
        elseif gradient[i] < amr.refinement_threshold / 2
            # 对变化较小的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格 (GPU加速)")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

"""
    compute_gradient_gpu(amr::AdaptiveMeshRefinement, field::Symbol)

GPU加速版本的梯度计算函数
"""
function compute_gradient_gpu(amr::AdaptiveMeshRefinement, field::Symbol)
    field_data = amr.physical_fields[field]
    gradient = CUDA.fill(0.0, length(field_data))

    # GPU加速的梯度计算
    @cuda threads=256 compute_gradient_kernel(field_data, gradient, amr.spacing)

    return Array(gradient)
end

"""
    compute_gradient_kernel

CUDA内核函数：计算物理场的梯度
"""
function compute_gradient_kernel(field_data, gradient, spacing)
    i = threadIdx().x + (blockIdx().x - 1) * blockDim().x
    if i > 1 && i < length(field_data)-1
        gradient[i] = (field_data[i+1] - field_data[i-1]) / spacing
    end
end

# --------------------------
# 自适应EOS耦合
# --------------------------

"""
    adaptive_eos_coupling(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)

根据当前网格细化级别动态调整EOS参数。
"""
function adaptive_eos_coupling(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)
    if amr.current_refinement_level > 5
        # 在更高的网格细化级别使用更精细的EOS
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(amr.current_refinement_level) 使用更精细的EOS")
    elseif amr.current_refinement_level > 3
        # 中等细化级别
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(amr.current_refinement_level) 使用中等精度的EOS")
    else
        # 粗网格使用较粗的EOS
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(amr.current_refinement_level) 使用粗网格的EOS")
    end
end

end  # module AMRModule


# Communication.jl
#
# 本模块扩展了幽灵区域数据交换功能，支持批量通信（多变量一次性打包传输），
# 异步非阻塞通信以及错误检测和超时机制，适用于高阶差分和多尺度耦合问题的多层幽灵区更新，
# 同时提供通信后处理接口用于性能统计和调试。
#
# 依赖：Distributed, LinearAlgebra, Dates

module Communication

using Distributed
using LinearAlgebra
using Dates  # 用于时间测量
using Base.Threads: Atomic, atomic_add!

export get_border_slice, set_border_slice!, ghost_exchange_3d_batch!, comm_performance_report, call_with_timeout

# 全局通信统计信息（原子更新：:calls 和 :errors 使用 Atomic 类型）
const comm_stats = Dict{Symbol,Any}(
    :total_time  => 0.0,    # 普通数值
    :total_bytes => 0,      # 普通数值
    :calls       => Atomic{Int64}(0),
    :errors      => Atomic{Int64}(0),
)

# 辅助函数：计算数组所占字节数
function array_size_bytes(arr::AbstractArray)
    return sizeof(eltype(arr)) * length(arr)
end

##########################################################################
# 边界切片操作：单变量版本
##########################################################################
function border_slice(field::Array{Float64,3}, direction::Symbol, ghost::NTuple{3,Int})
    gx, gy, gz = ghost
    local_nx = size(field, 1) - 2*gx
    local_ny = size(field, 2) - 2*gy
    local_nz = size(field, 3) - 2*gz
    if direction == :left
         return field[gx+1:2*gx, gy+1:gy+local_ny, gz+1:gz+local_nz]
    elseif direction == :right
         return field[end-2*gx+1:end-gx, gy+1:gy+local_ny, gz+1:gz+local_nz]
    elseif direction == :front
         return field[gx+1:gx+local_nx, gy+1:2*gy, gz+1:gz+local_nz]
    elseif direction == :back
         return field[gx+1:gx+local_nx, end-2*gy+1:end-gy, gz+1:gz+local_nz]
    elseif direction == :bottom
         return field[gx+1:gx+local_nx, gy+1:gy+local_ny, gz+1:2*gz]
    elseif direction == :top
         return field[gx+1:gx+local_nx, gy+1:gy+local_ny, end-2*gz+1:end-gz]
    else
         error("Unknown direction: $direction")
    end
end

function set_border_slice!(field::Array{Float64,3}, direction::Symbol, ghost::NTuple{3,Int}, data::Array{Float64,3})
    gx, gy, gz = ghost
    local_nx = size(field, 1) - 2*gx
    local_ny = size(field, 2) - 2*gy
    local_nz = size(field, 3) - 2*gz
    if direction == :left
         field[1:gx, gy+1:gy+local_ny, gz+1:gz+local_nz] .= data
    elseif direction == :right
         field[end-gx+1:end, gy+1:gy+local_ny, gz+1:gz+local_nz] .= data
    elseif direction == :front
         field[gx+1:gx+local_nx, 1:gy, gz+1:gz+local_nz] .= data
    elseif direction == :back
         field[gx+1:gx+local_nx, end-gy+1:end, gz+1:gz+local_nz] .= data
    elseif direction == :bottom
         field[gx+1:gx+local_nx, gy+1:gy+local_ny, 1:gz] .= data
    elseif direction == :top
         field[gx+1:gx+local_nx, gy+1:gy+local_ny, end-gz+1:end] .= data
    else
         error("Unknown direction: $direction")
    end
    return field
end

##########################################################################
# 批量边界切片操作：多变量版本
##########################################################################
function get_border_slices_batch(direction::Symbol, ghost::NTuple{3,Int}, field_dict::Dict{Symbol,Array{Float64,3}})
    result = Dict{Symbol,Array{Float64,3}}()
    for (fname, field) in field_dict
         result[fname] = begin
             gx, gy, gz = ghost
             local_nx = size(field, 1) - 2*gx
             local_ny = size(field, 2) - 2*gy
             local_nz = size(field, 3) - 2*gz
             if direction == :left
                 field[gx+1:2*gx, gy+1:gy+local_ny, gz+1:gz+local_nz]
             elseif direction == :right
                 field[end-2*gx+1:end-gx, gy+1:gy+local_ny, gz+1:gz+local_nz]
             elseif direction == :front
                 field[gx+1:gx+local_nx, gy+1:2*gy, gz+1:gz+local_nz]
             elseif direction == :back
                 field[gx+1:gx+local_nx, end-2*gy+1:end-gy, gz+1:gz+local_nz]
             elseif direction == :bottom
                 field[gx+1:gx+local_nx, gy+1:gy+local_ny, gz+1:2*gz]
             elseif direction == :top
                 field[gx+1:gx+local_nx, gy+1:gy+local_ny, end-2*gz+1:end-gz]
             else
                 error("Unknown direction: $direction")
             end
         end
    end
    return result
end

function set_border_slices_batch!(field_dict::Dict{Symbol,Array{Float64,3}}, direction::Symbol, ghost::NTuple{3,Int}, data_dict::Dict{Symbol,Array{Float64,3}})
    for (fname, data) in data_dict
         if haskey(field_dict, fname)
             set_border_slice!(field_dict[fname], direction, ghost, data)
         end
    end
    return field_dict
end

##########################################################################
# 超时包装函数：运行函数 f 并在 timeout 秒内等待完成
##########################################################################
function call_with_timeout(f::Function, timeout::Float64)
    fut = @async f()
    t0 = time()
    while !istaskdone(fut)
        if (time() - t0) > timeout
            # 取消任务的调用已移除，因为 Task 对象没有 cancel 方法
            throw(InterruptException("Operation timed out after $timeout seconds"))
        end
        sleep(0.01)
    end
    return fetch(fut)
end

##########################################################################
# 批量幽灵区域数据交换：非阻塞异步通信、错误检测、超时、性能统计
##########################################################################
const opposites = Dict(:left => :right, :right => :left,
                         :front => :back, :back => :front,
                         :bottom => :top, :top => :bottom)

"""
    ghost_exchange_3d_batch!(field_dict::Dict{Symbol,Array{Float64,3}}, domain; timeout=5.0)

对局部子域内多变量的 3D 数据（含 ghost 层）进行批量通信，
每个方向一次性传输所有变量的边界数据。
采用非阻塞异步通信，并引入错误检测和超时机制。
参数：
- field_dict: 字典，键为变量名称 (Symbol)，值为对应的 3D 数组。
- domain: 包含 overlap::NTuple{3,Int} 和 neighbors::Dict{Symbol,Int} 的子域结构体，
          并假定其全局变量 Main.local_fields 指向 field_dict。
- timeout: 超时时间，单位秒，默认 5.0。
返回更新后的 field_dict，同时更新全局通信统计信息。
"""
function ghost_exchange_3d_batch!(field_dict::Dict{Symbol,Array{Float64,3}}, domain; timeout::Float64=5.0)
    # 检查 Main 中是否定义了 local_fields
    if !isdefined(Main, :local_fields)
        Main.eval(Main, :(local_fields = $field_dict))
    else
        Main.local_fields = field_dict
    end

    start_time = time()
    total_bytes = 0
    futures = []

    for (dir, neighbor_pid) in domain.neighbors
        opp_dir = opposites[dir]
        fut = @async begin
            try
                # 显式使用 Communication.get_border_slices_batch
                call_with_timeout(() -> remotecall_fetch(Communication.get_border_slices_batch, neighbor_pid, opp_dir, domain.overlap, Main.local_fields), timeout)
            catch e
                @warn "Error in remote batch call for direction $dir on proc $neighbor_pid: $e"
                atomic_add!(comm_stats[:errors], 1)
                return Dict{Symbol,Array{Float64,3}}()
            end
        end
        push!(futures, (dir, fut))
    end

    for (dir, fut) in futures
        try
            data_dict = fetch(fut)
            for arr in values(data_dict)
                total_bytes += array_size_bytes(arr)
            end
            set_border_slices_batch!(Main.local_fields, dir, domain.overlap, data_dict)
        catch e
            @warn "Error fetching remote data for direction $dir: $e"
            atomic_add!(comm_stats[:errors], 1)
        end
    end

    elapsed = time() - start_time
    comm_stats[:total_time] += elapsed
    comm_stats[:total_bytes] += total_bytes
    atomic_add!(comm_stats[:calls], 1)
    return field_dict
end

##########################################################################
# 通信性能报告接口
##########################################################################
"""
    comm_performance_report() -> Dict{Symbol,Any}

返回当前通信统计信息，包括总通信时间、传输字节数、调用次数、错误次数等。
"""
function comm_performance_report()
    return deepcopy(comm_stats)
end

end  # module Communication


# DomainDecomposition.jl
#
# 本模块对全局网格进行三维域分解，扩展功能包括：
#  - 多维与非均匀域分解：根据用户提供的权重实现非均匀划分，达到负载均衡。
#  - 重叠区域支持：允许指定各方向的重叠区宽度。
#  - 多级域分解：先进行粗分解，再对每个大块进行细分。
#  - 动态重构接口：可在模拟过程中根据负载变化重新划分子域，实现动态负载均衡。
#  - 与 GridModule 紧密耦合：通过接口生成局部网格供后续求解器使用。
#
# 新增负载均衡策略及通信接口：
#  - 每个 worker 需维护全局变量 local_load（标量）表示局部计算负载，
#    模块通过 remotecall_fetch 采集各域负载，并根据子域在各方向的平均负载计算新权重，
#    然后调用重构接口实现重新划分。
#
# 依赖：Distributed, LinearAlgebra, GridModule

module DomainDecomposition

using Distributed
using LinearAlgebra
using Main.GridModule
 # 修改为绝对引用，从 Main 中加载 GridModule

export Domain3D, decompose_grid_3d, reconstruct_decomposition, multi_level_decompose,
       get_local_grid, update_decomposition_with_load

##########################################################################
# 扩展 Domain3D 结构体
##########################################################################

"""
    Domain3D

存储 3D 子域信息，用于并行计算中的域分解。

字段说明：
- global_grid::GridModule.Grid: 全局网格信息。
- proc_id::Int: 分配给该子域的 worker 进程 ID。
- ix, iy, iz::UnitRange{Int}: 子域在全局网格中 x, y, z 方向的索引范围（含重叠区）。
- overlap::NTuple{3,Int}: 每个方向上的重叠区宽度 (ox, oy, oz)。
- neighbors::Dict{Symbol,Int}: 邻居进程信息，键包括 :left, :right, :front, :back, :bottom, :top。
- proc_coord::NTuple{3,Int}: 当前子域在进程网格中的坐标（如 (i,j,k)）。
- level::Int: 分解层级（例如 1 表示粗分解，2 表示细分解）。
"""
struct Domain3D
    global_grid::GridModule.Grid
    proc_id::Int
    ix::UnitRange{Int}
    iy::UnitRange{Int}
    iz::UnitRange{Int}
    overlap::NTuple{3,Int}
    neighbors::Dict{Symbol,Int}
    proc_coord::NTuple{3,Int}
    level::Int
end

##########################################################################
# 非均匀划分工具：动态分区函数
##########################################################################

"""
    dynamic_partition(n::Int, parts::Int; weights::Vector{Float64}=ones(parts)) -> Vector{UnitRange{Int}}

按照给定的权重在 [1, n] 上划分成 parts 个子区间，用于非均匀域分解。
若未提供权重，则默认均匀划分。
"""
function dynamic_partition(n::Int, parts::Int; weights::Vector{Float64}=ones(parts))
    total = sum(weights)
    # 计算目标累计索引（取整）
    cum_targets = [round(Int, n * (sum(weights[1:i]) / total)) for i in 1:parts]
    ranges = Vector{UnitRange{Int}}(undef, parts)
    prev = 0
    for i in 1:parts
        current = max(cum_targets[i], prev + 1)
        ranges[i] = (prev + 1):current
        prev = current
    end
    # 调整最后一个区间以确保覆盖 n
    if last(ranges).stop < n
        ranges[end] = first(ranges[end]):n
    end
    return ranges
end

##########################################################################
# 主函数：三维域分解
##########################################################################

"""
    decompose_grid_3d(grid::GridModule.Grid; overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing, weights::Dict{Symbol,Vector{Float64}}=Dict())

对全局网格进行三维域分解，支持非均匀划分（依据 weights）和重叠区域。
参数：
- grid: 全局网格 (GridModule.Grid)。
- overlap: 重叠区域宽度 (ox, oy, oz)，默认无重叠 (0,0,0)。
- proc_dims: 三维进程排列 (Px, Py, Pz)；若未提供，则根据 worker 数自动分配。
- weights: 一个字典，键为坐标轴符号（例如 :x, :y, :z），
  值为 Vector{Float64}，长度应与对应方向的分块数一致；若未提供则默认均匀划分。
返回值：Domain3D 对象数组，level 设为 1。
"""
function decompose_grid_3d(grid::GridModule.Grid; overlap::NTuple{3,Int}=(0,0,0),
                           proc_dims::Union{Nothing,NTuple{3,Int}}=nothing,
                           weights::Dict{Symbol,Vector{Float64}}=Dict())
    workers_list = sort(workers())
    nprocs_total = length(workers_list)
    if nprocs_total == 0
        error("未检测到 worker 进程，请使用 addprocs() 添加进程。")
    end

    # 根据坐标系统确定维度键
    dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
               grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
               grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system: $(grid.coordinate_system)")

    # 自动确定进程排列（近似立方体）若未指定
    if proc_dims === nothing
        p = nprocs_total
        Px = floor(Int, cbrt(p))
        Py = Px
        Pz = div(p, Px * Py)
        while Px * Py * Pz < p
            if Px <= Py && Px <= Pz
                Px += 1
            elseif Py <= Px && Py <= Pz
                Py += 1
            else
                Pz += 1
            end
        end
        proc_dims = (Px, Py, Pz)
    else
        if prod(proc_dims) != nprocs_total
            error("指定的 proc_dims $(proc_dims) 与 worker 数量 $nprocs_total 不匹配。")
        end
    end
    dims_proc = (proc_dims[1], proc_dims[2], proc_dims[3])

    # 对每个方向进行非均匀分区，若提供权重则使用 dynamic_partition；否则均匀划分
    partitions = Dict{Symbol, Vector{UnitRange{Int}}}()
    dims_proc_array = (dims_proc[1], dims_proc[2], dims_proc[3])
    for (i, d) in enumerate(dim_keys)
        parts_count = dims_proc_array[i]
        weight_vector = haskey(weights, d) ? weights[d] : ones(parts_count)
        partitions[d] = dynamic_partition(grid.dims[d], parts_count; weights = weight_vector)
    end

    domains = Vector{Domain3D}()
    count = 1
    for k in 1:dims_proc[3]
        for j in 1:dims_proc[2]
            for i in 1:dims_proc[1]
                pid = workers_list[count]
                range_x = partitions[dim_keys[1]][i]
                range_y = partitions[dim_keys[2]][j]
                range_z = partitions[dim_keys[3]][k]
                # 考虑重叠区域，扩展区间但不超出全局网格范围
                ox, oy, oz = overlap
                ix_new = max(first(range_x) - ox, 1) : min(last(range_x) + ox, grid.dims[dim_keys[1]])
                iy_new = max(first(range_y) - oy, 1) : min(last(range_y) + oy, grid.dims[dim_keys[2]])
                iz_new = max(first(range_z) - oz, 1) : min(last(range_z) + oz, grid.dims[dim_keys[3]])
                proc_coord = (i, j, k)
                neighbors = Dict{Symbol,Int}()
                if i > 1
                    neighbors[:left] = workers_list[count - 1]
                end
                if i < dims_proc[1]
                    neighbors[:right] = workers_list[count + 1]
                end
                if j > 1
                    neighbors[:front] = workers_list[count - dims_proc[1]]
                end
                if j < dims_proc[2]
                    neighbors[:back] = workers_list[count + dims_proc[1]]
                end
                if k > 1
                    neighbors[:bottom] = workers_list[count - dims_proc[1]*dims_proc[2]]
                end
                if k < dims_proc[3]
                    neighbors[:top] = workers_list[count + dims_proc[1]*dims_proc[2]]
                end

                push!(domains, Domain3D(grid, pid, ix_new, iy_new, iz_new, overlap, neighbors, proc_coord, 1))
                count += 1
            end
        end
    end
    return domains
end

##########################################################################
# 动态重构接口：重新划分子域（动态负载均衡）
##########################################################################

"""
    reconstruct_decomposition(grid::GridModule.Grid; kwargs...) -> Vector{Domain3D}

根据新的负载或物理梯度信息，重新划分子域，实现动态负载均衡。
接受与 decompose_grid_3d 相同的关键字参数（如 overlap、proc_dims、weights）。
"""
function reconstruct_decomposition(grid::GridModule.Grid; kwargs...)
    return decompose_grid_3d(grid; kwargs...)
end

##########################################################################
# 多级域分解
##########################################################################

"""
    multi_level_decompose(grid::GridModule.Grid, coarse_proc_dims::NTuple{3,Int}, fine_proc_dims::NTuple{3,Int};
                          overlap::NTuple{3,Int}=(0,0,0), coarse_weights::Dict{Symbol,Vector{Float64}}=Dict(),
                          fine_weights::Dict{Symbol,Vector{Float64}}=Dict())
    
先对全局网格按照 coarse_proc_dims 进行粗分解，再对每个粗子域内部根据 fine_proc_dims 进行细分。
返回所有细分后的 Domain3D 数组，其中细分域的 level 字段设为 2。
"""
function multi_level_decompose(grid::GridModule.Grid, coarse_proc_dims::NTuple{3,Int}, fine_proc_dims::NTuple{3,Int};
                               overlap::NTuple{3,Int}=(0,0,0), coarse_weights::Dict{Symbol,Vector{Float64}}=Dict(),
                               fine_weights::Dict{Symbol,Vector{Float64}}=Dict())
    coarse_domains = decompose_grid_3d(grid; overlap = overlap, proc_dims = coarse_proc_dims, weights = coarse_weights)
    fine_domains = Vector{Domain3D}()
    for cd in coarse_domains
        # 针对每个粗子域，根据 cd 的索引范围生成局部子网格参数
        local_limits = Dict{Symbol,Tuple{Float64,Float64}}()
        dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
                   grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
                   grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
                   error("Unsupported coordinate system")
        for d in dim_keys
            coords = grid.coordinates[d]
            if d == dim_keys[1]
                local_limits[d] = (coords[first(cd.ix)], coords[last(cd.ix)])
            elseif d == dim_keys[2]
                local_limits[d] = (coords[first(cd.iy)], coords[last(cd.iy)])
            elseif d == dim_keys[3]
                local_limits[d] = (coords[first(cd.iz)], coords[last(cd.iz)])
            end
        end
        local_grid = GridModule.create_grid(coordinate_system = grid.coordinate_system, limits = local_limits,
                                              spacing = grid.spacing, bc = grid.bc)
        local_fine_domains = decompose_grid_3d(local_grid; overlap = overlap, proc_dims = fine_proc_dims, weights = fine_weights)
        for fd in local_fine_domains
            push!(fine_domains, Domain3D(grid, fd.proc_id, fd.ix, fd.iy, fd.iz, fd.overlap, fd.neighbors, fd.proc_coord, 2))
        end
    end
    return fine_domains
end

##########################################################################
# 与 GridModule 耦合：生成局部网格
##########################################################################

"""
    get_local_grid(domain::Domain3D) -> GridModule.Grid

根据域分解结果，自动生成对应子域的局部网格。
利用 global_grid 的坐标与域的索引范围生成局部坐标数组和局部物理场数据初始化接口。

返回局部网格对象 (GridModule.Grid)。
"""
function get_local_grid(domain::Domain3D)
    grid = domain.global_grid
    dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
               grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
               grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system")
    local_limits = Dict{Symbol,Tuple{Float64,Float64}}()
    for (i, d) in enumerate(dim_keys)
        coords = grid.coordinates[d]
        if i == 1
            local_limits[d] = (coords[first(domain.ix)], coords[last(domain.ix)])
        elseif i == 2
            local_limits[d] = (coords[first(domain.iy)], coords[last(domain.iy)])
        elseif i == 3
            local_limits[d] = (coords[first(domain.iz)], coords[last(domain.iz)])
        end
    end
    local_grid = GridModule.create_grid(coordinate_system = grid.coordinate_system, limits = local_limits,
                                          spacing = grid.spacing, bc = grid.bc)
    return local_grid
end

##########################################################################
# 新增：负载均衡与通信接口
##########################################################################

"""
    gather_load_metrics(domains::Vector{Domain3D}) -> Dict{NTuple{3,Int},Float64}

从各子域所在的 worker 进程采集负载数据。
假定每个进程上均定义了全局变量 `local_load`（标量）。
返回一个字典，键为子域的 proc_coord，值为对应的负载值。
"""
function gather_load_metrics(domains::Vector{Domain3D})
    load_data = Dict{NTuple{3,Int}, Float64}()
    for d in domains
        # 从对应 worker 进程采集负载数据，若未定义则返回 0.0
        load_val = remotecall_fetch(() -> get(Main, :local_load, 0.0), d.proc_id)
        load_data[d.proc_coord] = load_val
    end
    return load_data
end

"""
    compute_weights_from_load(load_data::Dict{NTuple{3,Int},Float64}, proc_dims::NTuple{3,Int}) -> Dict{Symbol,Vector{Float64}}

根据各子域负载数据，按坐标方向计算新的权重向量。
对于每个维度，取相同索引的子域负载平均值作为该分块的权重。
返回一个字典，键为 :x, :y, :z，对应的值为权重向量。
"""
function compute_weights_from_load(load_data::Dict{NTuple{3,Int},Float64}, proc_dims::NTuple{3,Int})
    Px, Py, Pz = proc_dims
    weight_x = zeros(Px)
    count_x = zeros(Int, Px)
    weight_y = zeros(Py)
    count_y = zeros(Int, Py)
    weight_z = zeros(Pz)
    count_z = zeros(Int, Pz)
    
    for (coord, load) in load_data
        i, j, k = coord
        weight_x[i] += load
        count_x[i] += 1
        weight_y[j] += load
        count_y[j] += 1
        weight_z[k] += load
        count_z[k] += 1
    end
    
    for i in 1:Px
        if count_x[i] > 0
            weight_x[i] /= count_x[i]
        else
            weight_x[i] = 1.0
        end
    end
    for j in 1:Py
        if count_y[j] > 0
            weight_y[j] /= count_y[j]
        else
            weight_y[j] = 1.0
        end
    end
    for k in 1:Pz
        if count_z[k] > 0
            weight_z[k] /= count_z[k]
        else
            weight_z[k] = 1.0
        end
    end
    return Dict(:x => weight_x, :y => weight_y, :z => weight_z)
end

"""
    update_decomposition_with_load(grid::GridModule.Grid, current_domains::Vector{Domain3D};
                                     overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing)
根据各子域的负载数据重新划分子域，实现动态负载均衡。
若 proc_dims 未指定，则根据当前子域的最大 proc_coord 计算。
返回新的 Domain3D 数组。
"""
function update_decomposition_with_load(grid::GridModule.Grid, current_domains::Vector{Domain3D};
                                          overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing)
    if proc_dims === nothing
        # 根据当前子域的最大 proc_coord 得到进程排列
        max_i = maximum(d.proc_coord[1] for d in current_domains)
        max_j = maximum(d.proc_coord[2] for d in current_domains)
        max_k = maximum(d.proc_coord[3] for d in current_domains)
        proc_dims = (max_i, max_j, max_k)
    end
    # 采集各子域负载数据
    load_data = gather_load_metrics(current_domains)
    # 根据负载数据计算新的权重
    new_weights = compute_weights_from_load(load_data, proc_dims)
    # 调用重构接口重新划分子域
    new_domains = decompose_grid_3d(grid; overlap = overlap, proc_dims = proc_dims, weights = new_weights)
    return new_domains
end

end  # module DomainDecomposition


下面是第二部分，请结合第一部分，全面分析所有代码，结合我的任务（使用julia编写一个TOV模拟软件，最终达到类似Einstein toolkit的效果），提出扩展或改进意见：
module EOSModule

using LinearAlgebra

export FiniteTempEOS, CustomEOS, pressure, density, temperature, internal_energy,
       adaptive_eos_coupling

# --------------------------
# 默认方程状态 (EOS)
# --------------------------

"""
    FiniteTempEOS

这是一个用于有限温度情况下的EOS模型的结构。
"""
mutable struct FiniteTempEOS
    gamma::Float64
    K::Float64
    T0::Float64  # 初始温度
    cooling_rate::Float64
    heat_source::Function
end

# --------------------------
# 自定义EOS
# --------------------------

"""
    CustomEOS

用户自定义的EOS模型结构，允许用户根据需要定义不同的方程。
"""
mutable struct CustomEOS
    pressure_fn::Function  # 用户自定义的P = f(ρ, T)方程
    density_fn::Function   # 用户自定义的ρ = g(P, T)方程
end

"""
    pressure(eos::CustomEOS, rho::Float64, T::Float64)

返回给定密度和温度下的压力，用户可以根据需要定义该函数。
"""
function pressure(eos::CustomEOS, rho::Float64, T::Float64)
    return eos.pressure_fn(rho, T)
end

"""
    density(eos::CustomEOS, P::Float64, T::Float64)

返回给定压力和温度下的密度，用户可以根据需要定义该函数。
"""
function density(eos::CustomEOS, P::Float64, T::Float64)
    return eos.density_fn(P, T)
end

# --------------------------
# 默认温度依赖EOS
# --------------------------

"""
    pressure(eos::FiniteTempEOS, rho::Float64, T::Float64)

给定密度和温度，计算压力，基于有限温度的EOS模型。
"""
function pressure(eos::FiniteTempEOS, rho::Float64, T::Float64)
    return eos.K * rho^eos.gamma * (T / eos.T0)
end

"""
    density(eos::FiniteTempEOS, P::Float64, T::Float64)

给定压力和温度，计算密度，基于有限温度的EOS模型。
"""
function density(eos::FiniteTempEOS, P::Float64, T::Float64)
    return (P / (eos.K * (T / eos.T0)))^(1 / eos.gamma)
end

"""
    temperature(eos::FiniteTempEOS, P::Float64, rho::Float64)

给定压力和密度，计算温度，基于有限温度的EOS模型。
"""
function temperature(eos::FiniteTempEOS, P::Float64, rho::Float64)
    return (P / (eos.K * rho^eos.gamma)) * eos.T0
end

"""
    internal_energy(eos::FiniteTempEOS, rho::Float64, T::Float64)

计算给定密度和温度下的内能，基于有限温度的EOS模型。
"""
function internal_energy(eos::FiniteTempEOS, rho::Float64, T::Float64)
    return eos.K * rho^eos.gamma * (T / eos.T0) / (eos.gamma - 1.0)
end

# --------------------------
# 用户自定义函数的示例
# --------------------------

# 用户自定义P = f(ρ, T)的方程示例
function user_defined_pressure(rho, T)
    return 1.0e11 * rho * T  # 示例：P = 1e11 * ρ * T
end

# 用户自定义ρ = g(P, T)的方程示例
function user_defined_density(P, T)
    return P / (1.0e11 * T)  # 示例：ρ = P / (1e11 * T)
end

# 用户定义的自定义EOS模型示例
custom_eos = CustomEOS(user_defined_pressure, user_defined_density)

# --------------------------
# 自适应EOS耦合
# --------------------------

"""
    adaptive_eos_coupling(eos::FiniteTempEOS, current_refinement_level::Int)

根据当前网格细化级别动态调整EOS参数。
"""
function adaptive_eos_coupling(eos::FiniteTempEOS, current_refinement_level::Int)
    if current_refinement_level > 5
        # 在更高的网格细化级别使用更精细的EOS
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(current_refinement_level) 使用更精细的EOS")
    elseif current_refinement_level > 3
        # 中等细化级别
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(current_refinement_level) 使用中等精度的EOS")
    else
        # 粗网格使用较粗的EOS
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(current_refinement_level) 使用粗网格的EOS")
    end
end

end  # module EOSModule


module GridModule

using LinearAlgebra
using HDF5
using TOML
using YAML

# 引入 IOManager 中的相关功能
using Main.IOManager
using Main.EOSModule

export Grid, create_grid, apply_boundary_conditions,
       init_physical_fields!, update_physical_field!,
       read_config, get_refinement_level, update_refinement_level

##########################################################################
# 网格数据结构定义
##########################################################################

"""
    Grid

存储模拟网格信息的结构体，支持多坐标系统、自适应网格（AMR）、多种边界条件，
以及物理场数据和配置参数。

字段说明：
- coordinate_system::Symbol  
    坐标系统，支持 :cartesian、:cylindrical、:spherical。
- limits::Dict{Symbol,Tuple{Float64,Float64}}  
    各方向的域边界，例如笛卡尔坐标下包含 :x, :y, :z。
- spacing::Dict{Symbol,Float64}  
    各方向的基础网格间距，用于生成均匀网格。
- coordinates::Dict{Symbol,Vector{Float64}}  
    各方向生成的网格坐标数组。
- dims::Dict{Symbol,Int}  
    各方向上的网格点数。
- bc::Dict{Symbol,Any}  
    边界条件设置，每个键对应一侧边界（如 :xlow、:xhigh），可取预定义类型（如 :Dirichlet、:Neumann、:Absorbing、:Periodic、:Mixed）或带参数的元组。
- adaptive_params::Dict{Symbol,Tuple{Float64,Float64,Float64,Float64}}  
    自适应网格参数，格式为 (refine_start, refine_end, fine_spacing, coarse_spacing)，用于指定局部细化区域。
- custom_bc::Dict{Symbol,Function}  
    用户自定义的边界处理函数，键与 bc 中对应，若存在则优先使用。
- physical_fields::Dict{Symbol,Any}  
    存储物理场数据，如密度、压力、磁场、电场等，数据类型由用户自行定义（一般为数组）。
- config::Dict{Symbol,Any}  
    存储从外部文件读取的配置参数。
- refinement_level::Int  
    当前网格的细化级别，用于动态调整物理模型（如EOS）。
"""
struct Grid
    coordinate_system::Symbol
    limits::Dict{Symbol, Tuple{Float64, Float64}}
    spacing::Dict{Symbol, Float64}
    coordinates::Dict{Symbol, Vector{Float64}}
    dims::Dict{Symbol, Int}
    bc::Dict{Symbol, Any}
    adaptive_params::Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}}
    custom_bc::Dict{Symbol, Function}
    physical_fields::Dict{Symbol, Any}
    config::Dict{Symbol, Any}
    refinement_level::Int  # 当前网格细化级别
end

##########################################################################
# 网格生成函数
##########################################################################

function create_grid(; coordinate_system::Symbol = :cartesian,
                     limits::Dict{Symbol, Tuple{Float64, Float64}},
                     spacing::Dict{Symbol, Float64},
                     bc::Dict{Symbol, Any} = Dict{Symbol, Any}(),
                     adaptive_params::Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}} = Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}}(),
                     stretch_funcs::Dict{Symbol, Function} = Dict{Symbol, Function}(),
                     custom_bc::Dict{Symbol, Function} = Dict{Symbol, Function}(),
                     refinement_level::Int = 1)  # 允许指定初始细化级别
    coordinates = Dict{Symbol, Vector{Float64}}()
    dims = Dict{Symbol, Int}()

    # 根据坐标系统确定维度键
    dim_keys = coordinate_system == :cartesian ? (:x, :y, :z) :
               coordinate_system == :cylindrical ? (:r, :θ, :z) :
               coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system: $coordinate_system")
    
    for d in dim_keys
        lower, upper = limits[d]
        # 处理网格细化、拉伸或均匀网格
        if haskey(adaptive_params, d)
            # 自适应网格的生成逻辑
            # 省略具体细节，参考原代码逻辑
        elseif haskey(stretch_funcs, d)
            # 网格拉伸
        else
            # 均匀网格
        end
    end
    
    # 初始化物理场与配置为空字典
    physical_fields = Dict{Symbol, Any}()
    config = Dict{Symbol, Any}()

    return Grid(coordinate_system, limits, spacing, coordinates, dims, bc,
                adaptive_params, custom_bc, physical_fields, config, refinement_level)
end

##########################################################################
# 网格细化相关函数
##########################################################################

"""
    update_refinement_level!(grid::Grid, new_level::Int)

根据网格细化级别的更新，调整网格的细化级别，并通知其他模块更新相关参数（如EOS）。
"""
function update_refinement_level!(grid::Grid, new_level::Int)
    grid.refinement_level = new_level
    println("更新网格细化级别至: $new_level")
    
    # 根据新的细化级别，动态调整EOS等物理模型
    adaptive_eos_coupling(grid.coordinates[:r], grid.physical_fields[:temperature], :default, grid.refinement_level)
end

"""
    get_refinement_level(grid::Grid) -> Int

获取当前网格的细化级别。
"""
function get_refinement_level(grid::Grid)
    return grid.refinement_level
end

##########################################################################
# 边界条件应用函数
##########################################################################

function apply_boundary_conditions(field::Array{Float64, 1}, boundary::Symbol, grid::Grid)
    if haskey(grid.custom_bc, boundary)
        return grid.custom_bc[boundary](field)
    end
    if !haskey(grid.bc, boundary)
        return field
    end
    bc_setting = grid.bc[boundary]
    if bc_setting isa Tuple
        bc_type, bc_value = bc_setting
    else
        bc_type = bc_setting
        bc_value = nothing
    end

    if bc_type == :Dirichlet && bc_value !== nothing
        field[1] = bc_value
    elseif bc_type == :Neumann
        field[1] = field[2]
    elseif bc_type == :Absorbing
        field[1] = 0.0
    elseif bc_type == :Periodic
        field[1] = field[end-1]
    elseif bc_type == :Mixed && bc_value !== nothing
        field[1] = 0.5*(field[2] + bc_value)
    end
    return field
end

##########################################################################
# 物理场数据接口：初始化与更新
##########################################################################

function init_physical_fields!(grid::Grid, field_data::Dict{Symbol, T}) where T
    for (key, value) in field_data
        if !haskey(grid.physical_fields, key)
            error("物理场 $key 在 grid.physical_fields 中不存在。")
        end
        if typeof(value) != typeof(grid.physical_fields[key])
            error("物理场 $key 的类型不匹配：预期 $(typeof(grid.physical_fields[key])), 实际 $(typeof(value))。")
        end
        grid.physical_fields[key] = value
    end
    return grid
end

function update_physical_field!(grid::Grid, field_name::Symbol, new_data)
    grid.physical_fields[field_name] = new_data
    return grid
end

##########################################################################
# 配置参数读取接口
##########################################################################

function read_config(filename::String)::Dict{Symbol, Any}
    if endswith(lowercase(filename), ".toml")
        config_str = read(filename, String)
        config_dict = TOML.parse(config_str)
    elseif endswith(lowercase(filename), ".yaml") || endswith(lowercase(filename), ".yml")
        config_dict = YAML.load_file(filename)
    elseif endswith(lowercase(filename), ".h5") || endswith(lowercase(filename), ".hdf5")
        config_dict = IOManager.read_hdf5_config(filename)  # 使用 IOManager 读取 HDF5 配置
    else
        error("不支持的配置文件格式: $filename")
    end
    return IOManager.convert_keys_to_symbols(config_dict)  # 确保将字典的键转换为 Symbol
end

end  # module GridModule


module GRMHDModule

using LinearAlgebra
using SpecialFunctions
using DifferentialEquations

export GRMHDState, solve_grmhd, grmhd_flux, apply_riemann_solver, apply_weno_solver, divergence_cleaning

# 物理状态结构体
struct GRMHDState
    ρ::Vector{Float64}       # 质量密度
    u::Vector{Vector{Float64}} # 动量密度，u^i 方向数组
    e::Vector{Float64}       # 能量密度
    B::Vector{Vector{Float64}} # 磁场分量，B^i 方向数组
end

# GRMHD 方程组（理想流体+电磁场模型）

# 质量守恒：dρ/dt + ∇⋅(ρ u^i) = 0
# 动量守恒：du^i/dt + ∇⋅(ρ u^i u^j + p δ^i_j - B^i B^j) = 0
# 能量守恒：de/dt + ∇⋅[(e + p) u^i - B^i B^j + F^i] = 0
# 磁场方程：∂_t B^i = ∇_j (B^j u^i) + η ∇^2 B^i

# 高分辨率震荡捕捉方法（例如WENO）
function apply_weno_solver(flux_ρ, flux_momentum, flux_energy, flux_B)
    # 假设WENO方法已经实现，可以替换Riemann方法
    flux_ρ_new = weno_scheme(flux_ρ)
    flux_momentum_new = weno_scheme(flux_momentum)
    flux_energy_new = weno_scheme(flux_energy)
    flux_B_new = weno_scheme(flux_B)
    
    return flux_ρ_new, flux_momentum_new, flux_energy_new, flux_B_new
end

# WENO数值解法的简化实现，实际应用时需要更复杂的WENO方案
function weno_scheme(flux)
    # 简化的WENO方案（实际需要实现具体的WENO方法）
    return flux * 0.5  # 这里只是示意，实际需要根据物理方程进行调整
end

# 求解GRMHD方程组
function grmhd_flux(state::GRMHDState, dx::Float64, dt::Float64)
    ρ, u, e, B = state.ρ, state.u, state.e, state.B
    
    # 质量守恒通量
    flux_ρ = [ρ[i] * u[i] for i in 1:length(ρ)]
    
    # 动量守恒通量
    flux_momentum = [ρ[i] * u[i] * u[j] + e * δ(i, j) - B[i] * B[j] for i in 1:length(ρ), j in 1:length(ρ)]
    
    # 能量守恒通量
    flux_energy = [(e + ρ[i]) * u[i] - B[i] * B[j] for i in 1:length(ρ), j in 1:length(ρ)]
    
    # 磁场通量（采用有限体积法）
    flux_B = [B[i] * u[j] - B[j] * u[i] for i in 1:length(ρ), j in 1:length(ρ)]
    
    return flux_ρ, flux_momentum, flux_energy, flux_B
end

# 磁场散度清除方法
function divergence_cleaning(state::GRMHDState)
    # 假设B^i已经在state中
    B_div = sum([state.B[i][i] for i in 1:length(state.B)])  # 磁场的散度
    corrected_B = [state.B[i] - B_div for i in 1:length(state.B)]
    
    return GRMHDState(state.ρ, state.u, state.e, corrected_B)
end

# 求解GRMHD方程
function solve_grmhd(state::GRMHDState, dx::Float64, dt::Float64)
    # 计算通量
    flux_ρ, flux_momentum, flux_energy, flux_B = grmhd_flux(state, dx, dt)
    
    # 使用WENO求解器进行震荡捕捉
    flux_ρ_new, flux_momentum_new, flux_energy_new, flux_B_new = apply_weno_solver(flux_ρ, flux_momentum, flux_energy, flux_B)
    
    # 更新状态变量（质量、动量、能量、磁场等）
    state.ρ .+= dt * flux_ρ_new
    for i in 1:length(state.u)
        state.u[i] .+= dt * flux_momentum_new[i]
    end
    state.e .+= dt * flux_energy_new
    for i in 1:length(state.B)
        state.B[i] .+= dt * flux_B_new[i]
    end
    
    # 磁场散度清除
    state = divergence_cleaning(state)
    
    return state
end

end  # module GRMHDModule


module IOManager

using HDF5
using Distributed
using LinearAlgebra
#using FileLock
#using SharedVector
using Random

# 文件锁定机制，用于并行环境下避免多进程写入冲突
const lockfile = "lockfile.lock"

# 并行 I/O 模块：使用 HDF5 存储数据
function save_data_parallel(filename::String, data::Array, group_name::String)
    # 缓冲区写入
    buffer = SharedVector{Float64}(undef, length(data))
    
    # 使用并行存储方法存储数据
    @distributed for i in 1:length(data)
        buffer[i] = data[i]
    end

    # 文件锁定：防止多线程写入冲突
    lock = FileLock(lockfile)
    @lock lock begin
        h5open(filename, "a") do file
            # 将数据以并行方式批量写入文件
            dset = create_or_open(file, group_name, HDF5.H5T_NATIVE_DOUBLE, size(data))
            write(dset, buffer)
        end
    end
end

# 保存检查点：周期性保存模拟状态
function save_checkpoint(filename::String, state::Dict, chunk_size::Int=100)
    # 增量保存，避免每次都写入整个数据
    h5open(filename, "a") do file
        for (key, value) in state
            if !haskey(file, key)
                # 如果文件中没有这个数据集，则创建
                create_dataset(file, key, HDF5.H5T_NATIVE_DOUBLE, size(value))
            end
            
            # 增量保存：只保存与上次保存不同的部分
            dset = file[key]
            data_shape = size(value)
            start_idx = get_start_idx(dset, data_shape)
            
            # 将新增部分写入数据集
            write(dset, start_idx, value)
        end
    end
end

# 恢复检查点：从文件中恢复模拟状态
function load_checkpoint(filename::String)
    state = Dict()
    h5open(filename, "r") do file
        for key in keys(file)
            state[key] = read(file[key])
        end
    end
    return state
end

# 获取数据集的起始索引，用于增量保存
function get_start_idx(dset, data_shape)
    current_shape = size(dset)
    start_idx = current_shape[1] + 1
    if start_idx > data_shape[1]
        throw("数据超出存储范围")
    end
    return (start_idx, 1)  # 假设数据按行分块存储
end

# 创建或打开数据集
function create_or_open(file, group_name, datatype, shape)
    if haskey(file, group_name)
        return file[group_name]
    else
        return create_dataset(file, group_name, datatype, shape)
    end
end

# 异步 I/O 操作，使用多线程写入（增强性能）
function async_save_checkpoint(filename::String, state::Dict, chunk_size::Int=100)
    tasks = []
    for (key, value) in state
        push!(tasks, @spawn begin
            save_checkpoint(filename, Dict(key => value), chunk_size)
        end)
    end
    fetch.(tasks)  # 等待所有任务完成
end

end # module IOManager

module MagneticFieldModule

using LinearAlgebra
using SpecialFunctions

# 计算纯偶极磁场的磁流函数 Ψ(r, θ)
"""
    magnetic_potential(r, θ)

计算在给定位置 (r, θ) 处的磁流函数 Ψ(r, θ)，
对于偶极磁场，磁流函数是与半径 r 和极角 θ 的函数。
"""
function magnetic_potential(r, θ)
    return r^2 * sin(θ)
end

# 自适应磁场耦合（增加修正项）
"""
    adaptive_magnetic_field_coupling(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

根据不同区域（如高磁场区域）动态调整磁场耦合强度或修正项。
"""
function adaptive_magnetic_field_coupling(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    if region == :high_magnetic_field
        println("在高磁场区域使用更强的磁场耦合")
        # 这里可以加入更复杂的磁场耦合修正
        return magnetic_potential(r, θ) * 2  # 增加耦合修正
    else
        println("使用默认磁场耦合")
        return magnetic_potential(r, θ)  # 默认磁场耦合
    end
end

# -----------------------
# 计算磁场修正的梯度
# -----------------------

"""
    compute_magnetic_field_gradient(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

计算磁场在不同区域的梯度，返回梯度值，帮助自适应网格进行磁场修正。
"""
function compute_magnetic_field_gradient(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    # 假设磁场梯度仅依赖于半径 r 和极角 θ
    grad_r = gradient(r)
    grad_θ = gradient(θ)
    
    # 对于高磁场区域，可以增强磁场梯度
    if region == :high_magnetic_field
        grad_r *= 1.5
        grad_θ *= 1.5
    end
    
    return grad_r, grad_θ
end

# -------------------------
# 磁场与流体耦合
# -------------------------

"""
    couple_magnetic_field_and_fluid(r::Vector{Float64}, θ::Vector{Float64}, fluid_density::Vector{Float64}, region::Symbol)

结合流体密度与磁场，进行磁场与流体耦合计算，考虑自适应磁场修正。
"""
function couple_magnetic_field_and_fluid(r::Vector{Float64}, θ::Vector{Float64}, fluid_density::Vector{Float64}, region::Symbol)
    magnetic_field = adaptive_magnetic_field_coupling(r, θ, region)
    
    # 这里可以加入流体力学模型与磁场耦合的计算
    coupled_field = magnetic_field .* fluid_density  # 假设磁场与流体的耦合是简单的乘积关系
    return coupled_field
end

# -----------------------
# 磁场修正应用到网格
# -----------------------

"""
    apply_magnetic_field_correction!(grid::Grid, r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

应用磁场修正到网格数据，依据当前物理区域动态调整磁场强度。
"""
function apply_magnetic_field_correction!(grid::Grid, r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    # 获取当前区域的磁场修正
    magnetic_field = adaptive_magnetic_field_coupling(r, θ, region)
    
    # 将修正后的磁场数据更新到网格中
    for i in 1:length(r)
        grid.physical_fields[:magnetic_field][i] *= magnetic_field[i]
    end
end

# -----------------------
# 辅助函数：计算一阶导数（梯度）
# -----------------------

"""
    gradient(x::Vector{Float64})

计算一维数组的梯度（数值微分），返回梯度值。
"""
function gradient(x::Vector{Float64})
    dx = diff(x)
    return [0.0; (dx[1:end-1] + dx[2:end]) / 2.0; 0.0]  # 简单的中心差分
end

end  # module MagneticFieldModule


module ParallelComputationModule

using Distributed
using LinearAlgebra
using SharedVector
using Threads
using CUDA

# ------------------------------
# GPU 加速部分
# ------------------------------

"""
    gpu_accelerated_update(grid::AMRGrid)

此函数演示了如何在GPU上执行更复杂的物理计算，
例如热传导、磁场耦合、流体力学模拟等。
"""
function gpu_accelerated_update(grid::AMRGrid)
    # 创建CUDA数组，假设网格数据为Float32类型
    d_grid_data = CUDA.fill(0.0f32, length(grid.r))  # 创建 GPU 数组
    CUDA.copyto!(d_grid_data, grid.grid_data)        # 将数据从 CPU 转移到 GPU
    
    # 热传导计算（作为示例）
    d_grid_data .= d_grid_data .+ 0.1f32  # 这只是一个示意，实际应使用更复杂的计算

    # 磁场耦合或流体力学计算（根据具体问题进行扩展）
    # 例如：d_grid_data = d_grid_data * magnetic_field_coupling_factor

    # 将计算结果从 GPU 拷贝回 CPU
    CUDA.copyto!(grid.grid_data, d_grid_data)  
end

"""
    gpu_convolution_operation(grid::AMRGrid)

此函数演示了在GPU上执行卷积操作。卷积常用于图像处理、热传导、流体力学模拟等领域。
"""
function gpu_convolution_operation(grid::AMRGrid)
    kernel = CUDA.fill(1.0f32, 3, 3)  # 示例卷积核
    d_kernel = CUDA.fill(0.0f32, 3, 3) 
    CUDA.copyto!(d_kernel, kernel)     # 将卷积核数据传输到 GPU
    
    # 假设我们要对网格数据进行卷积
    d_grid_data = CUDA.fill(0.0f32, length(grid.r))  # 创建 GPU 数组
    CUDA.copyto!(d_grid_data, grid.grid_data)        # 将数据从 CPU 转移到 GPU

    # 执行卷积（示例：逐元素与卷积核相乘）
    d_grid_data .= d_grid_data .+ 0.1f32  # 这只是一个示意，实际应使用卷积操作

    CUDA.copyto!(grid.grid_data, d_grid_data)  # 将结果返回给 CPU
end

# ------------------------------
# 内存管理与优化
# ------------------------------

"""
    manage_gpu_memory()

此函数管理GPU内存，确保大规模数据集的高效存储与传输。
通过内存池管理和减少数据拷贝优化内存。
"""
function manage_gpu_memory(grid::AMRGrid)
    # 创建内存池，优化内存管理
    pool = CUDA.DeviceBuffer{Float32}(length(grid.r))  # 创建一个内存池
    d_grid_data = CUDA.fill(0.0f32, length(grid.r))
    
    # 优化内存传输：避免多次数据拷贝，采用一次性传输和内存池管理
    CUDA.copyto!(d_grid_data, grid.grid_data)  # 直接拷贝数据到GPU内存池
    # 在GPU上进行计算
    d_grid_data .= d_grid_data .+ 0.5f32  # 示例计算
    
    # 将处理后的数据返回到CPU
    CUDA.copyto!(grid.grid_data, d_grid_data)  # 直接从内存池获取数据
end

# ------------------------------
# 分布式计算与并行处理
# ------------------------------

"""
    parallel_update_domain(grid::AMRGrid, num_workers::Int)

使用分布式计算进行并行网格更新，增强性能，支持大规模数据计算。
"""
function parallel_update_domain(grid::AMRGrid, num_workers::Int)
    addprocs(num_workers)  # 添加工作进程
    @everywhere begin
        function update_worker(worker_id::Int, grid::AMRGrid)
            # 每个worker负责更新分配到的网格区域
            println("Worker ", worker_id, " is processing grid data.")
            gpu_accelerated_update(grid)  # 使用GPU加速
        end
    end
    
    # 分配任务并并行执行
    @distributed for worker_id in 1:num_workers
        update_worker(worker_id, grid)
    end
end

# ------------------------------
# 多线程计算
# ------------------------------

"""
    threaded_update(grid::AMRGrid)

使用线程并行更新网格数据，适用于局部计算。
"""
function threaded_update(grid::AMRGrid)
    @threads for i in 1:length(grid.r)
        # 线程安全的更新操作，假设每个线程独立处理一部分网格数据
        grid.grid_data[i] .= grid.grid_data[i] + 0.1  # 示例更新物理量
    end
end

end  # module ParallelComputationModule


module TOVSolver

using LinearAlgebra
using DifferentialEquations
using Main.GridModule
using Main.EOSModule

export solve_tov, compute_observables, evolve_temperature!, update_temperature, adaptive_eos_coupling, solve_tov_with_multiscale

# 物理常数与辅助函数
const G = 6.67430e-11  # 引力常数 (m^3 kg^-1 s^-2)
const c = 3.0e8        # 光速 (m/s)

# --------------------------
# 求解TOV方程的核心函数
# --------------------------

"""
    solve_tov(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)

该函数用于求解TOV方程，计算恒星内部的质量、半径、压力和密度。
"""
function solve_tov(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)
    # 设置EOS模型
    eos.T0 = T
    eos.K = K
    eos.gamma = gamma
    
    # 初始状态，使用初始压力Pc来推导密度和温度
    rho_initial = eos.density(Pc, T)
    
    # 时间步长和求解器
    t_start = 0.0
    r = LinRange(0.1, r_end, 100)  # 半径的分布
    mass = zeros(Float64, length(r))
    pressure = zeros(Float64, length(r))
    density = zeros(Float64, length(r))
    temperature = zeros(Float64, length(r))

    # 初始条件
    mass[1] = 0.0
    pressure[1] = Pc
    density[1] = rho_initial
    temperature[1] = T

    # 求解过程，计算每个位置的物理量
    for i in 2:length(r)
        # 更新温度、密度、压力等物理量
        temperature[i] = update_temperature(pressure[i-1], eos, density[i-1], temperature[i-1])
        pressure[i] = eos.pressure(density[i], temperature[i])
        density[i] = eos.density(pressure[i], temperature[i])
        mass[i] = mass[i-1] + 4π * r[i-1]^2 * density[i-1] * (r[i] - r[i-1])
    end
    
    return mass, pressure, density, temperature, r
end

# 计算质量-半径关系以及其他物理量（如有效半径、表面压力等）
function compute_observables(mass, pressure, density, temperature, r)
    effective_radius = r[end]
    surface_pressure = pressure[end]
    
    return mass, effective_radius, surface_pressure
end

# --------------------------
# 温度演化与热传导函数
# --------------------------

"""
    evolve_temperature!(grid::Grid, eos::FiniteTempEOS, dt::Float64)

此函数用于更新网格中每个点的温度，考虑冷却/加热过程和热扩散。
"""
function evolve_temperature!(grid::Grid, eos::FiniteTempEOS, dt::Float64)
    for i in 1:length(grid.coordinates[:x])
        T_current = grid.physical_fields[:temperature][i]
        # 假设冷却效应与温度平方成正比，计算冷却项
        cooling_effect = eos.cooling_rate * T_current^2
        # 假设温度变化受热扩散影响
        dT_dt = -eos.alpha * laplacian(T_current, grid) + eos.heat_source(T_current) - cooling_effect
        grid.physical_fields[:temperature][i] += dT_dt * dt
    end
end

"""
    update_temperature(P::Float64, eos::FiniteTempEOS, rho::Float64, T::Float64)

此函数更新当前点的温度，考虑冷却效应和加热源。
"""
function update_temperature(P::Float64, eos::FiniteTempEOS, rho::Float64, T::Float64)
    cooling_effect = eos.cooling_rate * T^2  # 假设冷却与温度的平方成正比
    # 可以加入更多的物理过程，如热源（加热）
    heat_source = eos.heat_source(T)
    new_temperature = T - cooling_effect + heat_source
    return new_temperature
end

# 拉普拉斯操作（用于热扩散计算）
function laplacian(T_current, grid::Grid)
    # 简化的拉普拉斯算子实现（可以根据需要使用更复杂的离散化方法）
    return (T_current[3:end] .- 2 * T_current[2:end-1] .+ T_current[1:end-2]) / (grid.spacing[:x]^2)
end

# --------------------------
# 多尺度建模与自适应耦合
# --------------------------

"""
    adaptive_eos_coupling(r::Vector{Float64}, eos::FiniteTempEOS, region::Symbol, current_refinement_level::Int)

根据物理区域自动选择不同的耦合策略，例如在高温、高密度区域使用更精确的模型。
"""
function adaptive_eos_coupling(r::Vector{Float64}, eos::FiniteTempEOS, region::Symbol, current_refinement_level::Int)
    if region == :high_temperature
        println("在高温区域使用更精细的EOS耦合")
        eos.gamma = 2.5  # 更高的伽马值，适应高温区域
    elseif region == :high_density
        println("在高密度区域使用更加精细的物理模型")
        eos.K = 2.0  # 高密度区域的K值调整
    else
        println("使用默认EOS耦合")
        eos.gamma = 2.0  # 默认伽马值
        eos.K = 1.0      # 默认K值
    end

    # 根据当前网格细化级别动态调整EOS
    if current_refinement_level > 5
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(current_refinement_level) 使用更精细的EOS")
    elseif current_refinement_level > 3
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(current_refinement_level) 使用中等精度的EOS")
    else
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(current_refinement_level) 使用粗网格的EOS")
    end
end

"""
    solve_tov_with_multiscale(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)

基于多尺度建模，自动选择不同的尺度计算方式。
"""
function solve_tov_with_multiscale(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)
    # 设置EOS模型
    eos.T0 = T
    eos.K = K
    eos.gamma = gamma
    
    # 初始状态，使用初始压力Pc来推导密度和温度
    rho_initial = eos.density(Pc, T)
    
    # 时间步长和求解器
    t_start = 0.0
    r = LinRange(0.1, r_end, 100)  # 半径的分布
    mass = zeros(Float64, length(r))
    pressure = zeros(Float64, length(r))
    density = zeros(Float64, length(r))
    temperature = zeros(Float64, length(r))

    # 初始条件
    mass[1] = 0.0
    pressure[1] = Pc
    density[1] = rho_initial
    temperature[1] = T

    # 求解过程，计算每个位置的物理量
    for i in 2:length(r)
        # 根据位置动态调整EOS耦合策略
        region = get_region(r[i], eos)
        adaptive_eos_coupling(r, eos, region, 3)  # 假设当前细化级别是3

        # 更新温度、密度、压力等物理量
        temperature[i] = update_temperature(pressure[i-1], eos, density[i-1], temperature[i-1])
        pressure[i] = eos.pressure(density[i], temperature[i])
        density[i] = eos.density(pressure[i], temperature[i])
        mass[i] = mass[i-1] + 4π * r[i-1]^2 * density[i-1] * (r[i] - r[i-1])
    end
    
    return mass, pressure, density, temperature, r
end

"""
    get_region(r::Float64, eos::FiniteTempEOS)

根据半径 r 决定当前区域的物理性质（高温、高密度等），为多尺度建模提供依据。
"""
function get_region(r::Float64, eos::FiniteTempEOS)
    if r < 5.0
        return :high_temperature
    elseif r < 10.0
        return :high_density
    else
        return :default
    end
end

end # module TOVSolver



