
我希望使用julia编写一个TOV模拟软件，最终达到类似Einstein toolkit的效果，我是在使用julia编写代码，请输出符合语法和格式要求的代码，我希望每个jl模块文件前有一个简短的说明包括文件名，实现的功能，依赖等，同时使用中文对代码进行注释，不要用php或R等，我已经完成部分模块如下，由于字数限制，我会分成两部分发送，请在收到完整的两部分后进行分析，这是第一部分


module AMRModule

using LinearAlgebra
using CUDA

export AdaptiveMeshRefinement, refine_grid, refine_grid_by_value!, compute_gradient,
       adaptive_timestep, refine_grid_gpu!, compute_gradient_gpu, compute_gradient_kernel,
       adaptive_eos_coupling, refine_grid_combined!, compute_rotational_effect, compute_temperature_effect

# --------------------------
# 自适应网格细化 (AMR)
# --------------------------

"""
    AdaptiveMeshRefinement

自适应网格细化类，根据物理量的梯度自动调整网格分辨率。
"""
mutable struct AdaptiveMeshRefinement
    grid_size::Int
    max_refinement_level::Int
    min_refinement_level::Int
    refinement_threshold::Float64
    spacing::Float64
    coordinates::Dict{Symbol, Array{Float64, 1}}   # 用于存储不同维度的网格坐标
    physical_fields::Dict{Symbol, Array{Float64, 1}} # 存储物理场，如密度、温度、压力等
    current_refinement_level::Int  # 当前网格细化级别
    rotational_effect::Bool       # 是否考虑旋转效应
    temperature_effect::Bool      # 是否考虑温度效应
end

# --------------------------
# 网格细化函数
# --------------------------

"""
    refine_grid!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)

根据物理场的梯度自动细化网格，并根据网格细化级别动态调整EOS。
"""
function refine_grid!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient(amr, field)

    # 根据梯度细化网格
    for i in 1:length(gradient)
        if gradient[i] > amr.refinement_threshold
            # 对需要细化的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格")
        elseif gradient[i] < amr.refinement_threshold / 2
            # 对变化较小的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)

    # 计算旋转效应（如果需要）
    if amr.rotational_effect
        compute_rotational_effect(amr)
    end

    # 计算温度效应（如果需要）
    if amr.temperature_effect
        compute_temperature_effect(amr, eos)
    end
end

# --------------------------
# 根据物理场值细化网格
# --------------------------

"""
    refine_grid_by_value!(amr::AdaptiveMeshRefinement, field::Symbol, threshold::Float64, eos::FiniteTempEOS)

根据物理场的值自动细化网格，依据物理量的绝对值进行细化。
"""
function refine_grid_by_value!(amr::AdaptiveMeshRefinement, field::Symbol, threshold::Float64, eos::FiniteTempEOS)
    field_data = amr.physical_fields[field]

    for i in 1:length(field_data)
        if field_data[i] > threshold
            # 对物理场值超过阈值的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格，物理场值超过阈值")
        elseif field_data[i] < threshold / 2
            # 对物理场值较低的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格，物理场值低于阈值")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

# --------------------------
# 计算梯度
# --------------------------

"""
    compute_gradient(amr::AdaptiveMeshRefinement, field::Symbol)

计算物理场（如温度、密度、压力等）的梯度，帮助判断在哪些区域需要进行网格细化。
"""
function compute_gradient(amr::AdaptiveMeshRefinement, field::Symbol)
    field_data = amr.physical_fields[field]
    gradient = zeros(Float64, length(field_data))

    # 简化的梯度计算方法（可以使用更复杂的离散化方法）
    for i in 2:length(field_data)-1
        gradient[i] = (field_data[i+1] - field_data[i-1]) / (amr.spacing)
    end

    return gradient
end

# --------------------------
# 自适应时间步长选择
# --------------------------

"""
    adaptive_timestep!(amr::AdaptiveMeshRefinement, dt::Float64, eos::FiniteTempEOS)

根据物理场的梯度和网格大小自动调整时间步长。
"""
function adaptive_timestep!(amr::AdaptiveMeshRefinement, dt::Float64, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient(amr, :temperature)

    # 自动调整时间步长（例如在高梯度区域使用更小的时间步长）
    max_gradient = maximum(abs.(gradient))
    dt_adjustment_factor = 1.0 / (1.0 + max_gradient)  # 较大梯度区域，时间步长较小
    new_dt = dt * dt_adjustment_factor

    # 根据当前网格细化级别调整时间步长
    new_dt *= 2.0^(amr.current_refinement_level - 1)

    return new_dt
end

# --------------------------
# GPU加速相关功能
# --------------------------

"""
    refine_grid_gpu!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)

GPU加速版本的网格细化函数，利用CUDA加速梯度计算和网格细化过程，并根据细化级别调整EOS。
"""
function refine_grid_gpu!(amr::AdaptiveMeshRefinement, field::Symbol, eos::FiniteTempEOS)
    # 计算物理场的梯度
    gradient = compute_gradient_gpu(amr, field)

    # 根据梯度细化网格
    for i in 1:length(gradient)
        if gradient[i] > amr.refinement_threshold
            # 对需要细化的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格 (GPU加速)")
        elseif gradient[i] < amr.refinement_threshold / 2
            # 对变化较小的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格 (GPU加速)")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

"""
    compute_gradient_gpu(amr::AdaptiveMeshRefinement, field::Symbol)

GPU加速版本的梯度计算函数
"""
function compute_gradient_gpu(amr::AdaptiveMeshRefinement, field::Symbol)
    field_data = amr.physical_fields[field]
    gradient = CUDA.fill(0.0, length(field_data))

    # GPU加速的梯度计算
    @cuda threads=256 compute_gradient_kernel(field_data, gradient, amr.spacing)

    return Array(gradient)
end

"""
    compute_gradient_kernel

CUDA内核函数：计算物理场的梯度
"""
function compute_gradient_kernel(field_data, gradient, spacing)
    i = threadIdx().x + (blockIdx().x - 1) * blockDim().x
    if i > 1 && i < length(field_data)-1
        gradient[i] = (field_data[i+1] - field_data[i-1]) / spacing
    end
end

# --------------------------
# 自适应EOS耦合
# --------------------------

"""
    adaptive_eos_coupling(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)

根据当前网格细化级别动态调整EOS参数。
"""
function adaptive_eos_coupling(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)
    if amr.current_refinement_level > 5
        # 在更高的网格细化级别使用更精细的EOS
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(amr.current_refinement_level) 使用更精细的EOS")
    elseif amr.current_refinement_level > 3
        # 中等细化级别
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(amr.current_refinement_level) 使用中等精度的EOS")
    else
        # 粗网格使用较粗的EOS
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(amr.current_refinement_level) 使用粗网格的EOS")
    end
end

# --------------------------
# 旋转效应计算
# --------------------------

"""
    compute_rotational_effect(amr::AdaptiveMeshRefinement)

根据旋转效应计算新的物理场或修正网格。
"""
function compute_rotational_effect(amr::AdaptiveMeshRefinement)
    # 旋转效应的计算逻辑（例如修改惯性矩、角动量等）
    println("计算旋转效应...")
end

# --------------------------
# 温度效应计算
# --------------------------

"""
    compute_temperature_effect(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)

考虑温度效应对物理场的影响，调整温度相关的方程状态。
"""
function compute_temperature_effect(amr::AdaptiveMeshRefinement, eos::FiniteTempEOS)
    # 基于温度影响调整EOS
    println("计算温度效应...")
end

# --------------------------
# 结合梯度和物理场值的细化
# --------------------------

"""
    refine_grid_combined!(amr::AdaptiveMeshRefinement, field::Symbol, gradient_threshold::Float64, value_threshold::Float64, eos::FiniteTempEOS)

结合梯度和物理场值进行网格细化，在两个标准都满足的情况下细化网格。
"""
function refine_grid_combined!(amr::AdaptiveMeshRefinement, field::Symbol, gradient_threshold::Float64, value_threshold::Float64, eos::FiniteTempEOS)
    gradient = compute_gradient(amr, field)
    field_data = amr.physical_fields[field]

    for i in 1:length(gradient)
        if gradient[i] > gradient_threshold && field_data[i] > value_threshold
            # 对梯度和物理场值都满足条件的区域进行细化
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格，梯度和物理场值均满足条件")
        elseif gradient[i] < gradient_threshold / 2 && field_data[i] < value_threshold / 2
            # 对梯度和物理场值均较小的区域进行粗化
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格，梯度和物理场值均较低")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

end  # module AMRModule
module Communication

using LinearAlgebra
using Main.GridModule
using Main.GRMHDModule

export exchange_boundaries, gather_data, scatter_data, communicate_fields

# --------------------------
# 数据交换函数
# --------------------------

"""
    exchange_boundaries(grid::Grid)

该函数用于交换网格边界上的数据，确保每个计算单元之间的信息流动。
"""
function exchange_boundaries(grid::Grid)
    # Exchange the left and right boundaries
    for i in 1:length(grid.coordinates[:y])
        # Left boundary with right boundary
        grid.physical_fields[:density][1, i] = grid.physical_fields[:density][end, i]
        grid.physical_fields[:temperature][1, i] = grid.physical_fields[:temperature][end, i]
        grid.physical_fields[:pressure][1, i] = grid.physical_fields[:pressure][end, i]
        grid.physical_fields[:magnetic_field][1, i] = grid.physical_fields[:magnetic_field][end, i]
        grid.physical_fields[:current_density][1, i] = grid.physical_fields[:current_density][end, i]

        grid.physical_fields[:density][end, i] = grid.physical_fields[:density][1, i]
        grid.physical_fields[:temperature][end, i] = grid.physical_fields[:temperature][1, i]
        grid.physical_fields[:pressure][end, i] = grid.physical_fields[:pressure][1, i]
        grid.physical_fields[:magnetic_field][end, i] = grid.physical_fields[:magnetic_field][1, i]
        grid.physical_fields[:current_density][end, i] = grid.physical_fields[:current_density][1, i]
    end
    # Exchange the top and bottom boundaries
    for i in 1:length(grid.coordinates[:x])
        grid.physical_fields[:density][i, 1] = grid.physical_fields[:density][i, end]
        grid.physical_fields[:temperature][i, 1] = grid.physical_fields[:temperature][i, end]
        grid.physical_fields[:pressure][i, 1] = grid.physical_fields[:pressure][i, end]
        grid.physical_fields[:magnetic_field][i, 1] = grid.physical_fields[:magnetic_field][i, end]
        grid.physical_fields[:current_density][i, 1] = grid.physical_fields[:current_density][i, end]

        grid.physical_fields[:density][i, end] = grid.physical_fields[:density][i, 1]
        grid.physical_fields[:temperature][i, end] = grid.physical_fields[:temperature][i, 1]
        grid.physical_fields[:pressure][i, end] = grid.physical_fields[:pressure][i, 1]
        grid.physical_fields[:magnetic_field][i, end] = grid.physical_fields[:magnetic_field][i, 1]
        grid.physical_fields[:current_density][i, end] = grid.physical_fields[:current_density][i, 1]
    end
end

# --------------------------
# 数据收集与分发
# --------------------------

"""
    gather_data(grid::Grid, data::Dict, fields::Vector{Symbol})

将指定的物理字段收集到数据字典中，供后续计算使用。
"""
function gather_data(grid::Grid, data::Dict, fields::Vector{Symbol})
    for field in fields
        data[field] = grid.physical_fields[field]
    end
end

"""
    scatter_data!(grid::Grid, data::Dict, fields::Vector{Symbol})

将计算结果分发到网格的物理场中。
"""
function scatter_data!(grid::Grid, data::Dict, fields::Vector{Symbol})
    for field in fields
        grid.physical_fields[field] .= data[field]
    end
end

# --------------------------
# 通信与数据传输
# --------------------------

"""
    communicate_fields(grid::Grid, eos::FiniteTempEOS)

该函数用来进行网格间的通信，确保各计算单元的物理量保持一致。
"""
function communicate_fields(grid::Grid, eos::FiniteTempEOS)
    # 交换物理场的边界数据
    exchange_boundaries(grid)

    # 传递新的物理量数据到计算单元
    # 例如温度、密度等
    gather_data(grid, grid.communication_data, [:density, :temperature, :pressure, :magnetic_field, :current_density])

    # 对数据进行处理，优化计算
    # 如需要，可以在这里进行物理场的滤波或平滑
    process_data!(grid)

    # 将更新后的物理场数据分发回网格
    scatter_data!(grid, grid.communication_data, [:density, :temperature, :pressure, :magnetic_field, :current_density])
end

"""
    process_data!(grid::Grid)

对数据进行处理，例如物理场的滤波、平滑或其他数据优化步骤
"""
function process_data!(grid::Grid)
    # 可以加入对温度、压力或其他字段的平滑处理
    for i in 2:(length(grid.coordinates[:x])-1)
        for j in 2:(length(grid.coordinates[:y])-1)
            # 平滑操作，例如计算邻域平均
            grid.physical_fields[:density][i, j] = mean([grid.physical_fields[:density][i, j], 
                                                         grid.physical_fields[:density][i-1, j], 
                                                         grid.physical_fields[:density][i+1, j]])
            grid.physical_fields[:temperature][i, j] = mean([grid.physical_fields[:temperature][i, j], 
                                                            grid.physical_fields[:temperature][i-1, j], 
                                                            grid.physical_fields[:temperature][i+1, j]])
        end
    end
end

# --------------------------
# 数据同步与更新
# --------------------------

"""
    sync_fields(grid::Grid, eos::FiniteTempEOS)

同步网格上所有区域的物理场数据。
"""
function sync_fields(grid::Grid, eos::FiniteTempEOS)
    # 进行通信以确保各计算单元的数据同步
    communicate_fields(grid, eos)

    # 更新物理场数据
    for i in 1:length(grid.coordinates[:x])
        for j in 1:length(grid.coordinates[:y])
            # 更新每个位置的密度、温度、压力等物理量
            rho = grid.physical_fields[:density][i, j]
            T = grid.physical_fields[:temperature][i, j]
            P = eos.pressure(rho, T)
            grid.physical_fields[:pressure][i, j] = P
        end
    end
end

end # module Communication
# DomainDecomposition.jl
#
# 本模块对全局网格进行三维域分解，扩展功能包括：
#  - 多维与非均匀域分解：根据用户提供的权重实现非均匀划分，达到负载均衡。
#  - 重叠区域支持：允许指定各方向的重叠区宽度。
#  - 多级域分解：先进行粗分解，再对每个大块进行细分。
#  - 动态重构接口：可在模拟过程中根据负载变化重新划分子域，实现动态负载均衡。
#  - 与 GridModule 紧密耦合：通过接口生成局部网格供后续求解器使用。
#
# 新增负载均衡策略及通信接口：
#  - 每个 worker 需维护全局变量 local_load（标量）表示局部计算负载，
#    模块通过 remotecall_fetch 采集各域负载，并根据子域在各方向的平均负载计算新权重，
#    然后调用重构接口实现重新划分。
#
# 依赖：Distributed, LinearAlgebra, GridModule

module DomainDecomposition

using Distributed
using LinearAlgebra
using Main.GridModule
 # 修改为绝对引用，从 Main 中加载 GridModule

export Domain3D, decompose_grid_3d, reconstruct_decomposition, multi_level_decompose,
       get_local_grid, update_decomposition_with_load

##########################################################################
# 扩展 Domain3D 结构体
##########################################################################

"""
    Domain3D

存储 3D 子域信息，用于并行计算中的域分解。

字段说明：
- global_grid::GridModule.Grid: 全局网格信息。
- proc_id::Int: 分配给该子域的 worker 进程 ID。
- ix, iy, iz::UnitRange{Int}: 子域在全局网格中 x, y, z 方向的索引范围（含重叠区）。
- overlap::NTuple{3,Int}: 每个方向上的重叠区宽度 (ox, oy, oz)。
- neighbors::Dict{Symbol,Int}: 邻居进程信息，键包括 :left, :right, :front, :back, :bottom, :top。
- proc_coord::NTuple{3,Int}: 当前子域在进程网格中的坐标（如 (i,j,k)）。
- level::Int: 分解层级（例如 1 表示粗分解，2 表示细分解）。
"""
struct Domain3D
    global_grid::GridModule.Grid
    proc_id::Int
    ix::UnitRange{Int}
    iy::UnitRange{Int}
    iz::UnitRange{Int}
    overlap::NTuple{3,Int}
    neighbors::Dict{Symbol,Int}
    proc_coord::NTuple{3,Int}
    level::Int
end

##########################################################################
# 非均匀划分工具：动态分区函数
##########################################################################

"""
    dynamic_partition(n::Int, parts::Int; weights::Vector{Float64}=ones(parts)) -> Vector{UnitRange{Int}}

按照给定的权重在 [1, n] 上划分成 parts 个子区间，用于非均匀域分解。
若未提供权重，则默认均匀划分。
"""
function dynamic_partition(n::Int, parts::Int; weights::Vector{Float64}=ones(parts))
    total = sum(weights)
    # 计算目标累计索引（取整）
    cum_targets = [round(Int, n * (sum(weights[1:i]) / total)) for i in 1:parts]
    ranges = Vector{UnitRange{Int}}(undef, parts)
    prev = 0
    for i in 1:parts
        current = max(cum_targets[i], prev + 1)
        ranges[i] = (prev + 1):current
        prev = current
    end
    # 调整最后一个区间以确保覆盖 n
    if last(ranges).stop < n
        ranges[end] = first(ranges[end]):n
    end
    return ranges
end

##########################################################################
# 主函数：三维域分解
##########################################################################

"""
    decompose_grid_3d(grid::GridModule.Grid; overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing, weights::Dict{Symbol,Vector{Float64}}=Dict())

对全局网格进行三维域分解，支持非均匀划分（依据 weights）和重叠区域。
参数：
- grid: 全局网格 (GridModule.Grid)。
- overlap: 重叠区域宽度 (ox, oy, oz)，默认无重叠 (0,0,0)。
- proc_dims: 三维进程排列 (Px, Py, Pz)；若未提供，则根据 worker 数自动分配。
- weights: 一个字典，键为坐标轴符号（例如 :x, :y, :z），
  值为 Vector{Float64}，长度应与对应方向的分块数一致；若未提供则默认均匀划分。
返回值：Domain3D 对象数组，level 设为 1。
"""
function decompose_grid_3d(grid::GridModule.Grid; overlap::NTuple{3,Int}=(0,0,0),
                           proc_dims::Union{Nothing,NTuple{3,Int}}=nothing,
                           weights::Dict{Symbol,Vector{Float64}}=Dict())
    workers_list = sort(workers())
    nprocs_total = length(workers_list)
    if nprocs_total == 0
        error("未检测到 worker 进程，请使用 addprocs() 添加进程。")
    end

    # 根据坐标系统确定维度键
    dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
               grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
               grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system: $(grid.coordinate_system)")

    # 自动确定进程排列（近似立方体）若未指定
    if proc_dims === nothing
        p = nprocs_total
        Px = floor(Int, cbrt(p))
        Py = Px
        Pz = div(p, Px * Py)
        while Px * Py * Pz < p
            if Px <= Py && Px <= Pz
                Px += 1
            elseif Py <= Px && Py <= Pz
                Py += 1
            else
                Pz += 1
            end
        end
        proc_dims = (Px, Py, Pz)
    else
        if prod(proc_dims) != nprocs_total
            error("指定的 proc_dims $(proc_dims) 与 worker 数量 $nprocs_total 不匹配。")
        end
    end
    dims_proc = (proc_dims[1], proc_dims[2], proc_dims[3])

    # 对每个方向进行非均匀分区，若提供权重则使用 dynamic_partition；否则均匀划分
    partitions = Dict{Symbol, Vector{UnitRange{Int}}}()
    dims_proc_array = (dims_proc[1], dims_proc[2], dims_proc[3])
    for (i, d) in enumerate(dim_keys)
        parts_count = dims_proc_array[i]
        weight_vector = haskey(weights, d) ? weights[d] : ones(parts_count)
        partitions[d] = dynamic_partition(grid.dims[d], parts_count; weights = weight_vector)
    end

    domains = Vector{Domain3D}()
    count = 1
    for k in 1:dims_proc[3]
        for j in 1:dims_proc[2]
            for i in 1:dims_proc[1]
                pid = workers_list[count]
                range_x = partitions[dim_keys[1]][i]
                range_y = partitions[dim_keys[2]][j]
                range_z = partitions[dim_keys[3]][k]
                # 考虑重叠区域，扩展区间但不超出全局网格范围
                ox, oy, oz = overlap
                ix_new = max(first(range_x) - ox, 1) : min(last(range_x) + ox, grid.dims[dim_keys[1]])
                iy_new = max(first(range_y) - oy, 1) : min(last(range_y) + oy, grid.dims[dim_keys[2]])
                iz_new = max(first(range_z) - oz, 1) : min(last(range_z) + oz, grid.dims[dim_keys[3]])
                proc_coord = (i, j, k)
                neighbors = Dict{Symbol,Int}()
                if i > 1
                    neighbors[:left] = workers_list[count - 1]
                end
                if i < dims_proc[1]
                    neighbors[:right] = workers_list[count + 1]
                end
                if j > 1
                    neighbors[:front] = workers_list[count - dims_proc[1]]
                end
                if j < dims_proc[2]
                    neighbors[:back] = workers_list[count + dims_proc[1]]
                end
                if k > 1
                    neighbors[:bottom] = workers_list[count - dims_proc[1]*dims_proc[2]]
                end
                if k < dims_proc[3]
                    neighbors[:top] = workers_list[count + dims_proc[1]*dims_proc[2]]
                end

                push!(domains, Domain3D(grid, pid, ix_new, iy_new, iz_new, overlap, neighbors, proc_coord, 1))
                count += 1
            end
        end
    end
    return domains
end

##########################################################################
# 动态重构接口：重新划分子域（动态负载均衡）
##########################################################################

"""
    reconstruct_decomposition(grid::GridModule.Grid; kwargs...) -> Vector{Domain3D}

根据新的负载或物理梯度信息，重新划分子域，实现动态负载均衡。
接受与 decompose_grid_3d 相同的关键字参数（如 overlap、proc_dims、weights）。
"""
function reconstruct_decomposition(grid::GridModule.Grid; kwargs...)
    return decompose_grid_3d(grid; kwargs...)
end

##########################################################################
# 多级域分解
##########################################################################

"""
    multi_level_decompose(grid::GridModule.Grid, coarse_proc_dims::NTuple{3,Int}, fine_proc_dims::NTuple{3,Int};
                          overlap::NTuple{3,Int}=(0,0,0), coarse_weights::Dict{Symbol,Vector{Float64}}=Dict(),
                          fine_weights::Dict{Symbol,Vector{Float64}}=Dict())
    
先对全局网格按照 coarse_proc_dims 进行粗分解，再对每个粗子域内部根据 fine_proc_dims 进行细分。
返回所有细分后的 Domain3D 数组，其中细分域的 level 字段设为 2。
"""
function multi_level_decompose(grid::GridModule.Grid, coarse_proc_dims::NTuple{3,Int}, fine_proc_dims::NTuple{3,Int};
                               overlap::NTuple{3,Int}=(0,0,0), coarse_weights::Dict{Symbol,Vector{Float64}}=Dict(),
                               fine_weights::Dict{Symbol,Vector{Float64}}=Dict())
    coarse_domains = decompose_grid_3d(grid; overlap = overlap, proc_dims = coarse_proc_dims, weights = coarse_weights)
    fine_domains = Vector{Domain3D}()
    for cd in coarse_domains
        # 针对每个粗子域，根据 cd 的索引范围生成局部子网格参数
        local_limits = Dict{Symbol,Tuple{Float64,Float64}}()
        dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
                   grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
                   grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
                   error("Unsupported coordinate system")
        for d in dim_keys
            coords = grid.coordinates[d]
            if d == dim_keys[1]
                local_limits[d] = (coords[first(cd.ix)], coords[last(cd.ix)])
            elseif d == dim_keys[2]
                local_limits[d] = (coords[first(cd.iy)], coords[last(cd.iy)])
            elseif d == dim_keys[3]
                local_limits[d] = (coords[first(cd.iz)], coords[last(cd.iz)])
            end
        end
        local_grid = GridModule.create_grid(coordinate_system = grid.coordinate_system, limits = local_limits,
                                              spacing = grid.spacing, bc = grid.bc)
        local_fine_domains = decompose_grid_3d(local_grid; overlap = overlap, proc_dims = fine_proc_dims, weights = fine_weights)
        for fd in local_fine_domains
            push!(fine_domains, Domain3D(grid, fd.proc_id, fd.ix, fd.iy, fd.iz, fd.overlap, fd.neighbors, fd.proc_coord, 2))
        end
    end
    return fine_domains
end

##########################################################################
# 与 GridModule 耦合：生成局部网格
##########################################################################

"""
    get_local_grid(domain::Domain3D) -> GridModule.Grid

根据域分解结果，自动生成对应子域的局部网格。
利用 global_grid 的坐标与域的索引范围生成局部坐标数组和局部物理场数据初始化接口。

返回局部网格对象 (GridModule.Grid)。
"""
function get_local_grid(domain::Domain3D)
    grid = domain.global_grid
    dim_keys = grid.coordinate_system == :cartesian ? (:x, :y, :z) :
               grid.coordinate_system == :cylindrical ? (:r, :θ, :z) :
               grid.coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system")
    local_limits = Dict{Symbol,Tuple{Float64,Float64}}()
    for (i, d) in enumerate(dim_keys)
        coords = grid.coordinates[d]
        if i == 1
            local_limits[d] = (coords[first(domain.ix)], coords[last(domain.ix)])
        elseif i == 2
            local_limits[d] = (coords[first(domain.iy)], coords[last(domain.iy)])
        elseif i == 3
            local_limits[d] = (coords[first(domain.iz)], coords[last(domain.iz)])
        end
    end
    local_grid = GridModule.create_grid(coordinate_system = grid.coordinate_system, limits = local_limits,
                                          spacing = grid.spacing, bc = grid.bc)
    return local_grid
end

##########################################################################
# 新增：负载均衡与通信接口
##########################################################################

"""
    gather_load_metrics(domains::Vector{Domain3D}) -> Dict{NTuple{3,Int},Float64}

从各子域所在的 worker 进程采集负载数据。
假定每个进程上均定义了全局变量 `local_load`（标量）。
返回一个字典，键为子域的 proc_coord，值为对应的负载值。
"""
function gather_load_metrics(domains::Vector{Domain3D})
    load_data = Dict{NTuple{3,Int}, Float64}()
    for d in domains
        # 从对应 worker 进程采集负载数据，若未定义则返回 0.0
        load_val = remotecall_fetch(() -> get(Main, :local_load, 0.0), d.proc_id)
        load_data[d.proc_coord] = load_val
    end
    return load_data
end

"""
    compute_weights_from_load(load_data::Dict{NTuple{3,Int},Float64}, proc_dims::NTuple{3,Int}) -> Dict{Symbol,Vector{Float64}}

根据各子域负载数据，按坐标方向计算新的权重向量。
对于每个维度，取相同索引的子域负载平均值作为该分块的权重。
返回一个字典，键为 :x, :y, :z，对应的值为权重向量。
"""
function compute_weights_from_load(load_data::Dict{NTuple{3,Int},Float64}, proc_dims::NTuple{3,Int})
    Px, Py, Pz = proc_dims
    weight_x = zeros(Px)
    count_x = zeros(Int, Px)
    weight_y = zeros(Py)
    count_y = zeros(Int, Py)
    weight_z = zeros(Pz)
    count_z = zeros(Int, Pz)
    
    for (coord, load) in load_data
        i, j, k = coord
        weight_x[i] += load
        count_x[i] += 1
        weight_y[j] += load
        count_y[j] += 1
        weight_z[k] += load
        count_z[k] += 1
    end
    
    for i in 1:Px
        if count_x[i] > 0
            weight_x[i] /= count_x[i]
        else
            weight_x[i] = 1.0
        end
    end
    for j in 1:Py
        if count_y[j] > 0
            weight_y[j] /= count_y[j]
        else
            weight_y[j] = 1.0
        end
    end
    for k in 1:Pz
        if count_z[k] > 0
            weight_z[k] /= count_z[k]
        else
            weight_z[k] = 1.0
        end
    end
    return Dict(:x => weight_x, :y => weight_y, :z => weight_z)
end

"""
    update_decomposition_with_load(grid::GridModule.Grid, current_domains::Vector{Domain3D};
                                     overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing)
根据各子域的负载数据重新划分子域，实现动态负载均衡。
若 proc_dims 未指定，则根据当前子域的最大 proc_coord 计算。
返回新的 Domain3D 数组。
"""
function update_decomposition_with_load(grid::GridModule.Grid, current_domains::Vector{Domain3D};
                                          overlap::NTuple{3,Int}=(0,0,0), proc_dims::Union{Nothing,NTuple{3,Int}}=nothing)
    if proc_dims === nothing
        # 根据当前子域的最大 proc_coord 得到进程排列
        max_i = maximum(d.proc_coord[1] for d in current_domains)
        max_j = maximum(d.proc_coord[2] for d in current_domains)
        max_k = maximum(d.proc_coord[3] for d in current_domains)
        proc_dims = (max_i, max_j, max_k)
    end
    # 采集各子域负载数据
    load_data = gather_load_metrics(current_domains)
    # 根据负载数据计算新的权重
    new_weights = compute_weights_from_load(load_data, proc_dims)
    # 调用重构接口重新划分子域
    new_domains = decompose_grid_3d(grid; overlap = overlap, proc_dims = proc_dims, weights = new_weights)
    return new_domains
end

end  # module DomainDecomposition
module EOSModule

using LinearAlgebra

export FiniteTempEOS, CustomEOS, pressure, density, temperature, internal_energy,
       adaptive_eos_coupling

# --------------------------
# 默认方程状态 (EOS)
# --------------------------

"""
    FiniteTempEOS

这是一个用于有限温度情况下的EOS模型的结构。
"""
mutable struct FiniteTempEOS
    gamma::Float64
    K::Float64
    T0::Float64  # 初始温度
    cooling_rate::Float64
    heat_source::Function
end

# --------------------------
# 自定义EOS
# --------------------------

"""
    CustomEOS

用户自定义的EOS模型结构，允许用户根据需要定义不同的方程。
"""
mutable struct CustomEOS
    pressure_fn::Function  # 用户自定义的P = f(ρ, T)方程
    density_fn::Function   # 用户自定义的ρ = g(P, T)方程
end

"""
    pressure(eos::CustomEOS, rho::Float64, T::Float64)

返回给定密度和温度下的压力，用户可以根据需要定义该函数。
"""
function pressure(eos::CustomEOS, rho::Float64, T::Float64)
    return eos.pressure_fn(rho, T)
end

"""
    density(eos::CustomEOS, P::Float64, T::Float64)

返回给定压力和温度下的密度，用户可以根据需要定义该函数。
"""
function density(eos::CustomEOS, P::Float64, T::Float64)
    return eos.density_fn(P, T)
end

# --------------------------
# 默认温度依赖EOS
# --------------------------

"""
    pressure(eos::FiniteTempEOS, rho::Float64, T::Float64)

给定密度和温度，计算压力，基于有限温度的EOS模型。
"""
function pressure(eos::FiniteTempEOS, rho::Float64, T::Float64)
    return eos.K * rho^eos.gamma * (T / eos.T0)
end

"""
    density(eos::FiniteTempEOS, P::Float64, T::Float64)

给定压力和温度，计算密度，基于有限温度的EOS模型。
"""
function density(eos::FiniteTempEOS, P::Float64, T::Float64)
    return (P / (eos.K * (T / eos.T0)))^(1 / eos.gamma)
end

"""
    temperature(eos::FiniteTempEOS, P::Float64, rho::Float64)

给定压力和密度，计算温度，基于有限温度的EOS模型。
"""
function temperature(eos::FiniteTempEOS, P::Float64, rho::Float64)
    return (P / (eos.K * rho^eos.gamma)) * eos.T0
end

"""
    internal_energy(eos::FiniteTempEOS, rho::Float64, T::Float64)

计算给定密度和温度下的内能，基于有限温度的EOS模型。
"""
function internal_energy(eos::FiniteTempEOS, rho::Float64, T::Float64)
    return eos.K * rho^eos.gamma * (T / eos.T0) / (eos.gamma - 1.0)
end

# --------------------------
# 用户自定义函数的示例
# --------------------------

# 用户自定义P = f(ρ, T)的方程示例
function user_defined_pressure(rho, T)
    return 1.0e11 * rho * T  # 示例：P = 1e11 * ρ * T
end

# 用户自定义ρ = g(P, T)的方程示例
function user_defined_density(P, T)
    return P / (1.0e11 * T)  # 示例：ρ = P / (1e11 * T)
end

# 用户定义的自定义EOS模型示例
custom_eos = CustomEOS(user_defined_pressure, user_defined_density)

# --------------------------
# 自适应EOS耦合
# --------------------------

"""
    adaptive_eos_coupling(eos::FiniteTempEOS, current_refinement_level::Int)

根据当前网格细化级别动态调整EOS参数。
"""
function adaptive_eos_coupling(eos::FiniteTempEOS, current_refinement_level::Int)
    if current_refinement_level > 5
        # 在更高的网格细化级别使用更精细的EOS
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(current_refinement_level) 使用更精细的EOS")
    elseif current_refinement_level > 3
        # 中等细化级别
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(current_refinement_level) 使用中等精度的EOS")
    else
        # 粗网格使用较粗的EOS
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(current_refinement_level) 使用粗网格的EOS")
    end
end

end  # module EOSModule


这是第二部分，我希望你结合两部分内容分析如何进行测试

module GRMHDModule

using LinearAlgebra
using Main.GridModule
using Main.EOSModule
using Main.TOVSolver

export evolve_grmhd, compute_grmhd_fluxes, update_grmhd_fields, compute_magnetic_field, compute_current_density, adaptive_grmhd_refinement, adaptive_magnetic_field_coupling

# --------------------------
# 求解GRMHD方程的核心函数
# --------------------------

"""
    evolve_grmhd(grid::Grid, eos::FiniteTempEOS, dt::Float64)

该函数用于演化GRMHD方程，在每个时间步长更新磁场、密度、温度等物理量。
"""
function evolve_grmhd(grid::Grid, eos::FiniteTempEOS, dt::Float64)
    for i in 1:length(grid.coordinates[:x])
        rho = grid.physical_fields[:density][i]
        T = grid.physical_fields[:temperature][i]
        P = eos.pressure(rho, T)
        
        # 根据压力和温度更新磁场
        B = compute_magnetic_field(grid, eos, rho, T, P)
        
        # 更新GRMHD方程中的其他物理量
        J = compute_current_density(grid, eos)
        flux = compute_grmhd_fluxes(grid, eos)
        
        # 根据GRMHD方程演化密度、温度、磁场等
        update_grmhd_fields!(grid, eos, dt, B, J, flux)
    end
end

# --------------------------
# 磁场和电流密度计算
# --------------------------

"""
    compute_magnetic_field(grid::Grid, eos::FiniteTempEOS, rho::Float64, T::Float64, P::Float64)

该函数用于计算磁场强度，磁场不仅与温度和密度相关，还与流体动力学的耦合因素相关。
"""
function compute_magnetic_field(grid::Grid, eos::FiniteTempEOS, rho::Float64, T::Float64, P::Float64)
    # 计算磁场强度的基本因子
    base_B = eos.magnetic_strength_factor * (rho^0.5) * (T^0.25)

    # 进一步通过自适应磁场修正来考虑流体的影响
    B = adaptive_magnetic_field_coupling(grid, eos, rho, T, base_B)

    return B
end

"""
    compute_current_density(grid::Grid, eos::FiniteTempEOS)

计算电流密度，该函数可以结合电场和温度分布来计算
"""
function compute_current_density(grid::Grid, eos::FiniteTempEOS)
    # 这里只是一个示例，具体可以根据物理模型修改
    J = zeros(Float64, length(grid.coordinates[:x]))
    for i in 1:length(grid.coordinates[:x])
        T = grid.physical_fields[:temperature][i]
        J[i] = eos.current_density_factor * T^2
    end
    return J
end

# --------------------------
# GRMHD方程的演化
# --------------------------

"""
    compute_grmhd_fluxes(grid::Grid, eos::FiniteTempEOS)

该函数计算GRMHD方程中的能量和动量通量。
"""
function compute_grmhd_fluxes(grid::Grid, eos::FiniteTempEOS)
    flux = Dict()
    
    # 计算动量和能量通量，这里只给出示例
    flux[:momentum] = zeros(Float64, length(grid.coordinates[:x]))
    flux[:energy] = zeros(Float64, length(grid.coordinates[:x]))
    
    for i in 1:length(grid.coordinates[:x])
        rho = grid.physical_fields[:density][i]
        T = grid.physical_fields[:temperature][i]
        P = eos.pressure(rho, T)
        
        # 假设通量与密度和压力相关
        flux[:momentum][i] = rho * eos.velocity_factor * (P/rho)
        flux[:energy][i] = P + 0.5 * rho * eos.velocity_factor^2  # 只为示例
    end
    
    return flux
end

"""
    update_grmhd_fields!(grid::Grid, eos::FiniteTempEOS, dt::Float64, B::Vector{Float64}, J::Vector{Float64}, flux::Dict)

根据GRMHD方程更新物理场（磁场、电流密度、动量、能量等）。
"""
function update_grmhd_fields!(grid::Grid, eos::FiniteTempEOS, dt::Float64, B::Vector{Float64}, J::Vector{Float64}, flux::Dict)
    # 更新磁场、电流密度等
    for i in 1:length(grid.coordinates[:x])
        grid.physical_fields[:magnetic_field][i] += B[i] * dt
        grid.physical_fields[:current_density][i] += J[i] * dt
        grid.physical_fields[:density][i] += flux[:momentum][i] * dt
        grid.physical_fields[:temperature][i] += flux[:energy][i] * dt
    end
end

# --------------------------
# 自适应磁场耦合
# --------------------------

"""
    adaptive_magnetic_field_coupling(grid::Grid, eos::FiniteTempEOS, rho::Float64, T::Float64, base_B::Float64)

根据流体的密度、温度等物理场的变化，调整磁场耦合强度。
"""
function adaptive_magnetic_field_coupling(grid::Grid, eos::FiniteTempEOS, rho::Float64, T::Float64, base_B::Float64)
    # 基于密度、温度等物理量来调整磁场耦合因子
    density_factor = 1.0 + (rho - eos.reference_density) / eos.reference_density
    temperature_factor = 1.0 + (T - eos.reference_temperature) / eos.reference_temperature

    # 自适应修正磁场
    B = base_B * density_factor * temperature_factor
    
    # 进一步根据不同区域的物理条件调整磁场强度
    # 例如，密度较大的区域磁场可能需要更强的耦合
    for i in 1:length(grid.coordinates[:x])
        if rho > eos.high_density_threshold
            B[i] *= eos.high_density_magnetic_factor
        elseif rho < eos.low_density_threshold
            B[i] *= eos.low_density_magnetic_factor
        end
    end
    
    return B
end

# --------------------------
# 自适应网格细化
# --------------------------

"""
    adaptive_grmhd_refinement(grid::Grid, eos::FiniteTempEOS, threshold::Float64)

根据物理量的变化情况进行网格细化，自动选择细化区域
"""
function adaptive_grmhd_refinement(grid::Grid, eos::FiniteTempEOS, threshold::Float64)
    # 计算每个位置的物理量变化
    for i in 2:length(grid.coordinates[:x]) - 1
        pressure_gradient = abs(grid.physical_fields[:pressure][i] - grid.physical_fields[:pressure][i-1])
        temperature_gradient = abs(grid.physical_fields[:temperature][i] - grid.physical_fields[:temperature][i-1])
        
        # 判断是否需要细化
        if pressure_gradient > threshold || temperature_gradient > threshold
            refine_grid_combined!(grid, :pressure, 0.1, 1.0e8, eos)  # 细化网格
            refine_grid_combined!(grid, :temperature, 0.05, 1.0e9, eos)  # 细化温度网格
        end
    end
end

end # module GRMHDModule
module GridModule

using LinearAlgebra
using HDF5
using TOML
using YAML

# 引入 IOManager 中的相关功能
using Main.IOManager
using Main.EOSModule

export Grid, create_grid, apply_boundary_conditions,
       init_physical_fields!, update_physical_field!,
       read_config, get_refinement_level, update_refinement_level,
       refine_grid_combined!, refine_grid_by_value!, refine_grid!

##########################################################################
# 网格数据结构定义
##########################################################################

"""
    Grid

存储模拟网格信息的结构体，支持多坐标系统、自适应网格（AMR）、多种边界条件，
以及物理场数据和配置参数。

字段说明：
- coordinate_system::Symbol  
    坐标系统，支持 :cartesian、:cylindrical、:spherical。
- limits::Dict{Symbol,Tuple{Float64,Float64}}  
    各方向的域边界，例如笛卡尔坐标下包含 :x, :y, :z。
- spacing::Dict{Symbol,Float64}  
    各方向的基础网格间距，用于生成均匀网格。
- coordinates::Dict{Symbol,Vector{Float64}}  
    各方向生成的网格坐标数组。
- dims::Dict{Symbol,Int}  
    各方向上的网格点数。
- bc::Dict{Symbol,Any}  
    边界条件设置，每个键对应一侧边界（如 :xlow、:xhigh），可取预定义类型（如 :Dirichlet、:Neumann、:Absorbing、:Periodic、:Mixed）或带参数的元组。
- adaptive_params::Dict{Symbol,Tuple{Float64,Float64,Float64,Float64}}  
    自适应网格参数，格式为 (refine_start, refine_end, fine_spacing, coarse_spacing)，用于指定局部细化区域。
- custom_bc::Dict{Symbol,Function}  
    用户自定义的边界处理函数，键与 bc 中对应，若存在则优先使用。
- physical_fields::Dict{Symbol,Any}  
    存储物理场数据，如密度、压力、磁场、电场等，数据类型由用户自行定义（一般为数组）。
- config::Dict{Symbol,Any}  
    存储从外部文件读取的配置参数。
- refinement_level::Int  
    当前网格的细化级别，用于动态调整物理模型（如EOS）。
"""
struct Grid
    coordinate_system::Symbol
    limits::Dict{Symbol, Tuple{Float64, Float64}}
    spacing::Dict{Symbol, Float64}
    coordinates::Dict{Symbol, Vector{Float64}}
    dims::Dict{Symbol, Int}
    bc::Dict{Symbol, Any}
    adaptive_params::Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}}
    custom_bc::Dict{Symbol, Function}
    physical_fields::Dict{Symbol, Any}
    config::Dict{Symbol, Any}
    refinement_level::Int  # 当前网格细化级别
end

##########################################################################
# 网格生成函数
##########################################################################

function create_grid(; coordinate_system::Symbol = :cartesian,
                     limits::Dict{Symbol, Tuple{Float64, Float64}},
                     spacing::Dict{Symbol, Float64},
                     bc::Dict{Symbol, Any} = Dict{Symbol, Any}(),
                     adaptive_params::Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}} = Dict{Symbol, Tuple{Float64, Float64, Float64, Float64}}(),
                     stretch_funcs::Dict{Symbol, Function} = Dict{Symbol, Function}(),
                     custom_bc::Dict{Symbol, Function} = Dict{Symbol, Function}(),
                     refinement_level::Int = 1)  # 允许指定初始细化级别
    coordinates = Dict{Symbol, Vector{Float64}}()
    dims = Dict{Symbol, Int}()

    # 根据坐标系统确定维度键
    dim_keys = coordinate_system == :cartesian ? (:x, :y, :z) :
               coordinate_system == :cylindrical ? (:r, :θ, :z) :
               coordinate_system == :spherical ? (:r, :θ, :φ) :
               error("Unsupported coordinate system: $coordinate_system")
    
    for d in dim_keys
        lower, upper = limits[d]
        # 处理网格细化、拉伸或均匀网格
        if haskey(adaptive_params, d)
            # 自适应网格的生成逻辑
            # 省略具体细节，参考原代码逻辑
        elseif haskey(stretch_funcs, d)
            # 网格拉伸
        else
            # 均匀网格
        end
    end
    
    # 初始化物理场与配置为空字典
    physical_fields = Dict{Symbol, Any}()
    config = Dict{Symbol, Any}()

    return Grid(coordinate_system, limits, spacing, coordinates, dims, bc,
                adaptive_params, custom_bc, physical_fields, config, refinement_level)
end

##########################################################################
# 网格细化相关函数
##########################################################################

"""
    update_refinement_level!(grid::Grid, new_level::Int)

根据网格细化级别的更新，调整网格的细化级别，并通知其他模块更新相关参数（如EOS）。
"""
function update_refinement_level!(grid::Grid, new_level::Int)
    grid.refinement_level = new_level
    println("更新网格细化级别至: $new_level")
    
    # 根据新的细化级别，动态调整EOS等物理模型
    adaptive_eos_coupling(grid.coordinates[:r], grid.physical_fields[:temperature], :default, grid.refinement_level)
end

"""
    get_refinement_level(grid::Grid) -> Int

获取当前网格的细化级别。
"""
function get_refinement_level(grid::Grid)
    return grid.refinement_level
end

# --------------------------
# 网格细化函数
# --------------------------

"""
    refine_grid_combined!(amr::AdaptiveMeshRefinement, field::Symbol, gradient_threshold::Float64, value_threshold::Float64, eos::FiniteTempEOS)

结合梯度和物理场值进行网格细化，在两个标准都满足的情况下细化网格。
"""
function refine_grid_combined!(amr::AdaptiveMeshRefinement, field::Symbol, gradient_threshold::Float64, value_threshold::Float64, eos::FiniteTempEOS)
    gradient = compute_gradient(amr, field)
    field_data = amr.physical_fields[field]

    for i in 1:length(gradient)
        if gradient[i] > gradient_threshold && field_data[i] > value_threshold
            # 对梯度和物理场值都满足条件的区域进行细化
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格，梯度和物理场值均满足条件")
        elseif gradient[i] < gradient_threshold / 2 && field_data[i] < value_threshold / 2
            # 对梯度和物理场值均较小的区域进行粗化
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格，梯度和物理场值均较低")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

"""
    refine_grid_by_value!(amr::AdaptiveMeshRefinement, field::Symbol, threshold::Float64, eos::FiniteTempEOS)

根据物理场的值自动细化网格，依据物理量的绝对值进行细化。
"""
function refine_grid_by_value!(amr::AdaptiveMeshRefinement, field::Symbol, threshold::Float64, eos::FiniteTempEOS)
    field_data = amr.physical_fields[field]

    for i in 1:length(field_data)
        if field_data[i] > threshold
            # 对物理场值超过阈值的区域增加网格密度
            amr.grid_size += 1
            amr.current_refinement_level = min(amr.current_refinement_level + 1, amr.max_refinement_level)
            println("在第 $(i) 位置细化网格，物理场值超过阈值")
        elseif field_data[i] < threshold / 2
            # 对物理场值较低的区域减少网格密度
            amr.grid_size = max(amr.grid_size - 1, amr.min_refinement_level)
            amr.current_refinement_level = max(amr.current_refinement_level - 1, amr.min_refinement_level)
            println("在第 $(i) 位置粗化网格，物理场值低于阈值")
        end
    end

    # 根据当前网格细化级别调整EOS
    adaptive_eos_coupling(amr, eos)
end

end  # module GridModule
module IOManager

using HDF5
using Distributed
using LinearAlgebra
#using FileLock
#using SharedVector
using Random

# 文件锁定机制，用于并行环境下避免多进程写入冲突
const lockfile = "lockfile.lock"

# 并行 I/O 模块：使用 HDF5 存储数据
function save_data_parallel(filename::String, data::Array, group_name::String)
    # 缓冲区写入
    buffer = SharedVector{Float64}(undef, length(data))
    
    # 使用并行存储方法存储数据
    @distributed for i in 1:length(data)
        buffer[i] = data[i]
    end

    # 文件锁定：防止多线程写入冲突
    lock = FileLock(lockfile)
    @lock lock begin
        h5open(filename, "a") do file
            # 将数据以并行方式批量写入文件
            dset = create_or_open(file, group_name, HDF5.H5T_NATIVE_DOUBLE, size(data))
            write(dset, buffer)
        end
    end
end

# 保存检查点：周期性保存模拟状态
function save_checkpoint(filename::String, state::Dict, chunk_size::Int=100)
    # 增量保存，避免每次都写入整个数据
    h5open(filename, "a") do file
        for (key, value) in state
            if !haskey(file, key)
                # 如果文件中没有这个数据集，则创建
                create_dataset(file, key, HDF5.H5T_NATIVE_DOUBLE, size(value))
            end
            
            # 增量保存：只保存与上次保存不同的部分
            dset = file[key]
            data_shape = size(value)
            start_idx = get_start_idx(dset, data_shape)
            
            # 将新增部分写入数据集
            write(dset, start_idx, value)
        end
    end
end

# 恢复检查点：从文件中恢复模拟状态
function load_checkpoint(filename::String)
    state = Dict()
    h5open(filename, "r") do file
        for key in keys(file)
            state[key] = read(file[key])
        end
    end
    return state
end

# 获取数据集的起始索引，用于增量保存
function get_start_idx(dset, data_shape)
    current_shape = size(dset)
    start_idx = current_shape[1] + 1
    if start_idx > data_shape[1]
        throw("数据超出存储范围")
    end
    return (start_idx, 1)  # 假设数据按行分块存储
end

# 创建或打开数据集
function create_or_open(file, group_name, datatype, shape)
    if haskey(file, group_name)
        return file[group_name]
    else
        return create_dataset(file, group_name, datatype, shape)
    end
end

# 异步 I/O 操作，使用多线程写入（增强性能）
function async_save_checkpoint(filename::String, state::Dict, chunk_size::Int=100)
    tasks = []
    for (key, value) in state
        push!(tasks, @spawn begin
            save_checkpoint(filename, Dict(key => value), chunk_size)
        end)
    end
    fetch.(tasks)  # 等待所有任务完成
end

end # module IOManager
module MagneticFieldModule

using LinearAlgebra
using SpecialFunctions

# 计算纯偶极磁场的磁流函数 Ψ(r, θ)
"""
    magnetic_potential(r, θ)

计算在给定位置 (r, θ) 处的磁流函数 Ψ(r, θ)，
对于偶极磁场，磁流函数是与半径 r 和极角 θ 的函数。
"""
function magnetic_potential(r, θ)
    return r^2 * sin(θ)
end

# 自适应磁场耦合（增加修正项）
"""
    adaptive_magnetic_field_coupling(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

根据不同区域（如高磁场区域）动态调整磁场耦合强度或修正项。
"""
function adaptive_magnetic_field_coupling(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    if region == :high_magnetic_field
        println("在高磁场区域使用更强的磁场耦合")
        # 这里可以加入更复杂的磁场耦合修正
        return magnetic_potential(r, θ) * 2  # 增加耦合修正
    else
        println("使用默认磁场耦合")
        return magnetic_potential(r, θ)  # 默认磁场耦合
    end
end

# -----------------------
# 计算磁场修正的梯度
# -----------------------

"""
    compute_magnetic_field_gradient(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

计算磁场在不同区域的梯度，返回梯度值，帮助自适应网格进行磁场修正。
"""
function compute_magnetic_field_gradient(r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    # 假设磁场梯度仅依赖于半径 r 和极角 θ
    grad_r = gradient(r)
    grad_θ = gradient(θ)
    
    # 对于高磁场区域，可以增强磁场梯度
    if region == :high_magnetic_field
        grad_r *= 1.5
        grad_θ *= 1.5
    end
    
    return grad_r, grad_θ
end

# -------------------------
# 磁场与流体耦合
# -------------------------

"""
    couple_magnetic_field_and_fluid(r::Vector{Float64}, θ::Vector{Float64}, fluid_density::Vector{Float64}, region::Symbol)

结合流体密度与磁场，进行磁场与流体耦合计算，考虑自适应磁场修正。
"""
function couple_magnetic_field_and_fluid(r::Vector{Float64}, θ::Vector{Float64}, fluid_density::Vector{Float64}, region::Symbol)
    magnetic_field = adaptive_magnetic_field_coupling(r, θ, region)
    
    # 这里可以加入流体力学模型与磁场耦合的计算
    coupled_field = magnetic_field .* fluid_density  # 假设磁场与流体的耦合是简单的乘积关系
    return coupled_field
end

# -----------------------
# 磁场修正应用到网格
# -----------------------

"""
    apply_magnetic_field_correction!(grid::Grid, r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)

应用磁场修正到网格数据，依据当前物理区域动态调整磁场强度。
"""
function apply_magnetic_field_correction!(grid::Grid, r::Vector{Float64}, θ::Vector{Float64}, region::Symbol)
    # 获取当前区域的磁场修正
    magnetic_field = adaptive_magnetic_field_coupling(r, θ, region)
    
    # 将修正后的磁场数据更新到网格中
    for i in 1:length(r)
        grid.physical_fields[:magnetic_field][i] *= magnetic_field[i]
    end
end

# -----------------------
# 辅助函数：计算一阶导数（梯度）
# -----------------------

"""
    gradient(x::Vector{Float64})

计算一维数组的梯度（数值微分），返回梯度值。
"""
function gradient(x::Vector{Float64})
    dx = diff(x)
    return [0.0; (dx[1:end-1] + dx[2:end]) / 2.0; 0.0]  # 简单的中心差分
end

end  # module MagneticFieldModule
module ParallelComputationModule

using Distributed
using LinearAlgebra
using SharedVector
using Threads
using CUDA
using Base.Threads: Atomic, atomic_add!
using Random

# ------------------------------
# GPU 加速部分
# ------------------------------

"""
    gpu_accelerated_update(grid::AMRGrid)

此函数演示了如何在GPU上执行更复杂的物理计算，
例如热传导、磁场耦合、流体力学模拟等。
"""
function gpu_accelerated_update(grid::AMRGrid)
    # 创建CUDA数组，假设网格数据为Float32类型
    d_grid_data = CUDA.fill(0.0f32, length(grid.r))  # 创建 GPU 数组
    CUDA.copyto!(d_grid_data, grid.grid_data)        # 将数据从 CPU 转移到 GPU
    
    # 热传导计算（示例）
    temperature_gradient = compute_temperature_gradient(grid)
    d_grid_data .= d_grid_data .+ temperature_gradient * 0.1f32

    # 磁场耦合计算
    magnetic_field = compute_magnetic_field(grid)
    d_grid_data .= d_grid_data .+ magnetic_field * 0.05f32

    # 将计算结果从 GPU 拷贝回 CPU
    CUDA.copyto!(grid.grid_data, d_grid_data)  
end

"""
    compute_temperature_gradient(grid::AMRGrid)

计算网格上的温度梯度，作为热传导的基础。
"""
function compute_temperature_gradient(grid::AMRGrid)
    temp_grad = zeros(Float32, length(grid.r))
    for i in 2:length(grid.r)-1
        temp_grad[i] = (grid.grid_data[i+1] - grid.grid_data[i-1]) / 2.0f32
    end
    return temp_grad
end

"""
    compute_magnetic_field(grid::AMRGrid)

根据网格数据计算磁场，这里假设磁场与温度和密度有关。
"""
function compute_magnetic_field(grid::AMRGrid)
    magnetic_field = zeros(Float32, length(grid.r))
    for i in 1:length(grid.r)
        # 假设磁场与温度的关系
        magnetic_field[i] = grid.grid_data[i] * 0.05f32  # 示例计算
    end
    return magnetic_field
end

# ------------------------------
# 内存管理与优化
# ------------------------------

"""
    manage_gpu_memory()

此函数管理GPU内存，确保大规模数据集的高效存储与传输。
通过内存池管理和减少数据拷贝优化内存。
"""
function manage_gpu_memory(grid::AMRGrid)
    # 创建内存池，优化内存管理
    pool = CUDA.DeviceBuffer{Float32}(length(grid.r))  # 创建一个内存池
    d_grid_data = CUDA.fill(0.0f32, length(grid.r))
    
    # 优化内存传输：避免多次数据拷贝，采用一次性传输和内存池管理
    CUDA.copyto!(d_grid_data, grid.grid_data)  # 直接拷贝数据到GPU内存池
    # 在GPU上进行计算
    d_grid_data .= d_grid_data .+ 0.5f32  # 示例计算
    
    # 将处理后的数据返回到CPU
    CUDA.copyto!(grid.grid_data, d_grid_data)  # 直接从内存池获取数据
end

# ------------------------------
# 分布式计算与并行处理
# ------------------------------

"""
    parallel_update_domain(grid::AMRGrid, num_workers::Int)

使用分布式计算进行并行网格更新，增强性能，支持大规模数据计算。
"""
function parallel_update_domain(grid::AMRGrid, num_workers::Int)
    addprocs(num_workers)  # 添加工作进程
    @everywhere begin
        function update_worker(worker_id::Int, grid::AMRGrid)
            # 计算每个子任务的负载
            load = compute_task_load(grid)
            println("Worker ", worker_id, " is processing grid data with load ", load)
            
            # 动态负载均衡：根据负载信息调整工作分配
            if load > threshold
                # 假设阈值是根据计算需求设定的
                println("Worker ", worker_id, " is under heavy load, adjusting task.")
                # 动态调整任务
            end

            gpu_accelerated_update(grid)  # 使用GPU加速更新网格
        end
    end
    
    # 分配任务并并行执行
    @distributed for worker_id in 1:num_workers
        update_worker(worker_id, grid)
    end
end

"""
    compute_task_load(grid::AMRGrid)

根据每个网格的物理量计算当前任务的计算负载。
"""
function compute_task_load(grid::AMRGrid)
    total_load = 0.0f32
    for i in 1:length(grid.r)
        total_load += abs(grid.grid_data[i])  # 假设负载与网格数据相关
    end
    return total_load / length(grid.r)
end

# ------------------------------
# 异步计算与优化通信
# ------------------------------

"""
    async_gpu_exchange(data::Array{Float64}, device_id::Int)

异步GPU计算：将数据从CPU发送到GPU，执行计算后返回结果。
"""
function async_gpu_exchange(data::Array{Float64}, device_id::Int)
    if !CUDA.has_cuda()
        @warn "GPU 不可用！"
        return nothing
    end
    fut = @async begin
        try
            CUDA.device!(device_id)
            d_data = CuArray(data)
            d_result = d_data .^ 2  # 示例计算
            result = Array(d_result)
            return result
        catch e
            @warn "GPU 任务错误: $e"
            return nothing
        end
    end
    return fut
end

"""
    async_mixed_communication(data::Array{Float64}, device_id::Int)

混合异步通信：同时进行GPU计算和CPU计算，最后将结果汇总。
"""
function async_mixed_communication(data::Array{Float64}, device_id::Int)
    gpu_future = async_gpu_exchange(data, device_id)
    cpu_future = @async sum(data)
    return @async begin
        gpu_result = fetch(gpu_future)
        cpu_result = fetch(cpu_future)
        return (gpu_result, cpu_result)
    end
end

end  # module ParallelComputationModule
module TOVSolver

using LinearAlgebra
using DifferentialEquations
using Main.GridModule
using Main.EOSModule

export solve_tov, compute_observables, evolve_temperature!, update_temperature, adaptive_eos_coupling, solve_tov_with_multiscale

# 物理常数与辅助函数
const G = 6.67430e-11  # 引力常数 (m^3 kg^-1 s^-2)
const c = 3.0e8        # 光速 (m/s)

# --------------------------
# 求解TOV方程的核心函数
# --------------------------

"""
    solve_tov(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)

该函数用于求解TOV方程，计算恒星内部的质量、半径、压力和密度。
"""
function solve_tov(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)
    eos.T0 = T
    eos.K = K
    eos.gamma = gamma

    # 初始状态，使用初始压力Pc来推导密度和温度
    rho_initial = eos.density(Pc, T)
    
    # 在求解之前进行网格细化
    amr = AdaptiveMeshRefinement(
        grid_size=10,
        max_refinement_level=5,
        min_refinement_level=2,
        refinement_threshold=0.1,
        spacing=1.0,
        coordinates=Dict(:x => LinRange(0, r_end, 100)),
        physical_fields=Dict(:temperature => zeros(100), :pressure => zeros(100)),
        current_refinement_level=1
    )
    
    # 细化网格：基于压力和温度进行细化
    refine_grid_combined!(amr, :pressure, 0.1, 1.0e8, eos)  # Example: refine based on pressure
    refine_grid_combined!(amr, :temperature, 0.05, 1.0e9, eos)  # Example: refine based on temperature

    # 时间步长和求解器
    t_start = 0.0
    r = LinRange(0.1, r_end, 100)  # 半径的分布
    mass = zeros(Float64, length(r))
    pressure = zeros(Float64, length(r))
    density = zeros(Float64, length(r))
    temperature = zeros(Float64, length(r))

    # 初始条件
    mass[1] = 0.0
    pressure[1] = Pc
    density[1] = rho_initial
    temperature[1] = T

    # 求解过程，计算每个位置的物理量
    for i in 2:length(r)
        # 更新温度、密度、压力等物理量
        temperature[i] = update_temperature(pressure[i-1], eos, density[i-1], temperature[i-1])
        pressure[i] = eos.pressure(density[i], temperature[i])
        density[i] = eos.density(pressure[i], temperature[i])
        mass[i] = mass[i-1] + 4π * r[i-1]^2 * density[i-1] * (r[i] - r[i-1])
    end
    
    return mass, pressure, density, temperature, r
end

# 计算质量-半径关系以及其他物理量（如有效半径、表面压力等）
function compute_observables(mass, pressure, density, temperature, r)
    effective_radius = r[end]
    surface_pressure = pressure[end]
    
    return mass, effective_radius, surface_pressure
end

# --------------------------
# 温度演化与热传导函数
# --------------------------

"""
    evolve_temperature!(grid::Grid, eos::FiniteTempEOS, dt::Float64)

此函数用于更新网格中每个点的温度，考虑冷却/加热过程和热扩散。
"""
function evolve_temperature!(grid::Grid, eos::FiniteTempEOS, dt::Float64)
    for i in 1:length(grid.coordinates[:x])
        T_current = grid.physical_fields[:temperature][i]
        # 假设冷却效应与温度平方成正比，计算冷却项
        cooling_effect = eos.cooling_rate * T_current^2
        # 假设温度变化受热扩散影响
        heat_conductivity = eos.K * (T_current / eos.T0)  # 热传导系数与温度相关
        dT_dt = -heat_conductivity * laplacian(T_current, grid) + eos.heat_source(T_current) - cooling_effect
        grid.physical_fields[:temperature][i] += dT_dt * dt
    end
end

"""
    update_temperature(P::Float64, eos::FiniteTempEOS, rho::Float64, T::Float64)

此函数更新当前点的温度，考虑冷却效应和加热源。
"""
function update_temperature(P::Float64, eos::FiniteTempEOS, rho::Float64, T::Float64)
    cooling_effect = eos.cooling_rate * T^2  # 假设冷却与温度的平方成正比
    # 可以加入更多的物理过程，如热源（加热）
    heat_source = eos.heat_source(T)
    new_temperature = T - cooling_effect + heat_source
    return new_temperature
end

# 拉普拉斯操作（用于热扩散计算）
function laplacian(T_current, grid::Grid)
    # 改进的热传导方程，使用更高精度的离散化
    dx2 = grid.spacing[:x]^2
    return (T_current[3:end] .- 2 * T_current[2:end-1] .+ T_current[1:end-2]) / dx2
end

# --------------------------
# 多尺度建模与自适应耦合
# --------------------------

"""
    adaptive_eos_coupling(r::Vector{Float64}, eos::FiniteTempEOS, region::Symbol, current_refinement_level::Int)

根据物理区域自动选择不同的耦合策略，例如在高温、高密度区域使用更精确的模型。
"""
function adaptive_eos_coupling(r::Vector{Float64}, eos::FiniteTempEOS, region::Symbol, current_refinement_level::Int)
    if region == :high_temperature
        println("在高温区域使用更精细的EOS耦合")
        eos.gamma = 2.5  # 更高的伽马值，适应高温区域
    elseif region == :high_density
        println("在高密度区域使用更加精细的物理模型")
        eos.K = 2.0  # 高密度区域的K值调整
    else
        println("使用默认EOS耦合")
        eos.gamma = 2.0  # 默认伽马值
        eos.K = 1.0      # 默认K值
    end

    # 根据当前网格细化级别动态调整EOS
    if current_refinement_level > 5
        eos.gamma = 2.5
        eos.K = 1.5
        println("在细化级别 $(current_refinement_level) 使用更精细的EOS")
    elseif current_refinement_level > 3
        eos.gamma = 2.2
        eos.K = 1.2
        println("在细化级别 $(current_refinement_level) 使用中等精度的EOS")
    else
        eos.gamma = 2.0
        eos.K = 1.0
        println("在细化级别 $(current_refinement_level) 使用粗网格的EOS")
    end
end

"""
    solve_tov_with_multiscale(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)

基于多尺度建模，自动选择不同的尺度计算方式。
"""
function solve_tov_with_multiscale(Pc; K=1.0, gamma=2.0, T=1.0e6, eos, r_end=20.0, tol=1e-8, solver=:Rosenbrock23)
    eos.T0 = T
    eos.K = K
    eos.gamma = gamma
    
    # 初始状态，使用初始压力Pc来推导密度和温度
    rho_initial = eos.density(Pc, T)
    
    # 时间步长和求解器
    t_start = 0.0
    r = LinRange(0.1, r_end, 100)  # 半径的分布
    mass = zeros(Float64, length(r))
    pressure = zeros(Float64, length(r))
    density = zeros(Float64, length(r))
    temperature = zeros(Float64, length(r))

    # 初始条件
    mass[1] = 0.0
    pressure[1] = Pc
    density[1] = rho_initial
    temperature[1] = T

    # 求解过程，计算每个位置的物理量
    for i in 2:length(r)
        # 根据位置动态调整EOS耦合策略
        region = get_region(r[i], eos)
        adaptive_eos_coupling(r, eos, region, 3)  # 假设当前细化级别是3

        # 更新温度、密度、压力等物理量
        temperature[i] = update_temperature(pressure[i-1], eos, density[i-1], temperature[i-1])
        pressure[i] = eos.pressure(density[i], temperature[i])
        density[i] = eos.density(pressure[i], temperature[i])
        mass[i] = mass[i-1] + 4π * r[i-1]^2 * density[i-1] * (r[i] - r[i-1])
    end
    
    return mass, pressure, density, temperature, r
end

"""
    get_region(r::Float64, eos::FiniteTempEOS)

根据半径 r 决定当前区域的物理性质（高温、高密度等），为多尺度建模提供依据。
"""
function get_region(r::Float64, eos::FiniteTempEOS)
    if r < 5.0
        return :high_temperature
    elseif r < 10.0
        return :high_density
    else
        return :default
    end
end

end # module TOVSolver
